/***

    wForms 3.4
    a javascript extension to web forms. 

    Build $Sat, 23 Jul 2011 18:24:28 UTC$

    THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please
    diff against the source tree, not this file.

    Copyright (c) 2005-2007 Cedric Savarese <cedric@veerwest.com> and contributors.
    This software is licensed under the CC-GNU LGPL <http://creativecommons.org/licenses/LGPL/2.1/>
    For more information, visit: http://www.formassembly.com/wForms 

    Build script by Troels Knak-Nielsen <troelskn@gmail.com>
    wForms version 3.0 by Demid Nikitin and Cedric Savarese.
    wForms 3.0 requires base2 - copyright 2007, Dean Edwards. 
***/


if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms hint behavior. Show/highlight an HTML element when the associated input gets the focus.
 */
wFORMS.behaviors.hint  = { 
	
	/**
	 * Inactive CSS class for the element
     * @final
	 */
	CSS_INACTIVE : 'field-hint-inactive',

	/**
	 * Active CSS class for the element
     * @final
	 */
	CSS_ACTIVE : 'field-hint',

	/**
	 * Selector expression for the hint elements
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/
	 */
	HINT_SELECTOR : '*[id$="-H"]',

	/**
	 * Suffix of the ID for the hint element
     * @final
	 */
	HINT_SUFFIX : '-H',

	/**
	 * Creates new instance of the behavior
     * @constructor
	 */
	instance : function(f) {
		this.behavior = wFORMS.behaviors.hint; 
		this.target = f;
	}
}

/**
 * Factory Method.
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
wFORMS.behaviors.hint.applyTo = function(f) {
	var b = new wFORMS.behaviors.hint.instance(f);
	// Selects all hints elements using predefined selector and attaches
	// event listeners to related HTML elements for each hint
	if(!f.querySelectorAll) base2.DOM.bind(f);
	var elems = f.querySelectorAll(wFORMS.behaviors.hint.HINT_SELECTOR);
	
	if(!elems.forEach){
		//Make sure elems have forEach property since Opera doesn't let us override
		//StaticNodeList.prototype
		elems.forEach = NodeList.prototype.forEach;
	}
	
	elems.forEach(
		function(elem){
			
			// ID attribute is not checked here because selector already contains it
			// if selector is changed, ID check should also exists
			// if(!elem.id) { return ; }
			var e = b.getElementByHintId(elem.id);
			if(e){
				if(!e.addEventListener) base2.DOM.bind(e);
				if(e.tagName == "SELECT" || e.tagName == "TEXTAREA" || (e.tagName == "INPUT" && e.type != "radio" && e.type != "checkbox")){							
					e.addEventListener('focus', function(event) { b.run(event, this)}, false);
					e.addEventListener('blur',  function(event) { b.run(event, this)}, false);	
				} else {
					e.addEventListener('mouseover', function(event) { b.run(event, e)}, false);
					e.addEventListener('mouseout', function(event) { b.run(event, e)}, false);
				}
			}
		}
	);
	b.onApply();
	return b;
}

/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
wFORMS.behaviors.hint.instance.prototype.onApply = function() {} 

/**
 * Executes the behavior
 * @param {event} event
 * @param {domElement} elem
 */
wFORMS.behaviors.hint.instance.prototype.run = function(event, element) { 	
	
	var hint = this.getHintElement(element);
	if(!hint) return;
	if(!hint.removeClass) base2.DOM.bind(hint);
	
	if(event.type == 'focus' || event.type == 'mouseover'){
		hint.removeClass(wFORMS.behaviors.hint.CSS_INACTIVE)
		hint.addClass(wFORMS.behaviors.hint.CSS_ACTIVE);
		if (!wFORMS.helpers.getForm(element).hasClass('hintsSide')) {
			this.setup(hint, element);
		}
	} else{
		hint.addClass(wFORMS.behaviors.hint.CSS_INACTIVE);
		hint.removeClass(wFORMS.behaviors.hint.CSS_ACTIVE);
	}
}


/**
 * Returns HTMLElement related to specified hint ID
 * @returns	{HTMLElement}
 */
wFORMS.behaviors.hint.instance.prototype.getElementByHintId = function(hintId){
	var id = hintId.substr(0, hintId.length - wFORMS.behaviors.hint.HINT_SUFFIX.length);
	var e = document.getElementById(id);
	return e;
}

/**
 * Returns HTMLElement Hint element associated with element event catched from
 * @returns	{HTMLElement}
 */
wFORMS.behaviors.hint.instance.prototype.getHintElement = function(element){
	var e = document.getElementById(element.id + this.behavior.HINT_SUFFIX);
	if(e && !e.hasClass){base2.DOM.bind(e);}
	return e && e != '' ? e : null;
}

/**
 * Setups hint position on the screen depend on the element
 * @param	{HTMLElement}	hint	Hint HTML element
 * @param   {HTMLElement}	source	HTML element with focus.
 */
wFORMS.behaviors.hint.instance.prototype.setup = function(hint, field) {

	var fp = wFORMS.helpers.position(field);
	var hp = wFORMS.helpers.position(hint);
	var diff = {
		left: fp.left - hp.left,
		top: fp.top - hp.top
	};
	if (field.tagName.toLowerCase() == 'select') {
		hint.style.left = hint.offsetLeft + diff.left + field.offsetWidth +'px';
		hint.style.top = hint.offsetTop + diff.top +'px';
	} else {
		hint.style.left = hint.offsetLeft + diff.left +'px';
		hint.style.top = hint.offsetTop + diff.top + field.offsetHeight +'px';
	}
}

/**
 * Returns if ID is of the HINT element. Used by repeat behavior to correctly 
 * update hint ID
 * @param	{DOMString}	id
 * @return	boolean
 */
wFORMS.behaviors.hint.isHintId = function(id){
	return id.match(new RegExp(wFORMS.behaviors.hint.HINT_SUFFIX + '$')) != null;
}


if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms paging behavior. 
 * See: http://www.formassembly.com/blog/the-pagination-behavior-explained/
 */
wFORMS.behaviors.paging = {

	/**
	 * Selector expression for catching elements
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/
	 */
	SELECTOR : '.wfPage',

	/**
	 * CSS class indicates page
     * @final
	 */
	CSS_PAGE : 'wfPage',

	/**
	 * CSS class for current page
     * @final
	 */
	CSS_CURRENT_PAGE : 'wfCurrentPage',

	/**
	 * CSS class for next button
     * @final
	 */
	CSS_BUTTON_NEXT : 'wfPageNextButton',

	/**
	 * CSS class for next button
     * @final
	 */
	CSS_BUTTON_PREVIOUS : 'wfPagePreviousButton',
	
	/**
	 * CSS class for the div contains the previous/next buttons
     * @final
	 */
	CSS_BUTTON_PLACEHOLDER : 'wfPagingButtons',
	
	/**
	 * ID prefix for the next buttons
     * @final
	 */
	ID_BUTTON_NEXT_PREFIX : 'wfPageNextId',

	/**
	 * ID prefix for the previos buttons
     * @final
	 */
	ID_BUTTON_PREVIOUS_PREFIX : 'wfPagePreviousId',

	/**
	 * CSS class for hidden submit button
     * @final
	 */
	CSS_SUBMIT_HIDDEN : 'wfHideSubmit',

	/**
	 * ID attribute prefix for page area
     * @final
	 */
	ID_PAGE_PREFIX	: 'wfPgIndex-',

	/**
	 * ID attribute suffix for prev/next buttons placeholder
     * @final
	 */
	ID_PLACEHOLDER_SUFFIX : '-buttons',

	/**
	 * Attribute indicates index of the page button should activate
     * @final
	 */
	ATTR_INDEX : 'wfPageIndex_activate',

	/**
	 * Custom messages used for creating links
     * @final
	 */
	MESSAGES : {
		CAPTION_NEXT : 'Next Page',
		CAPTION_PREVIOUS : 'Previous Page',
		CAPTION_UNLOAD : 'Any data entered on ANY PAGE of this form will be LOST.'
	},

	/**
     * Indicates that form should be validated on Next clicked
     * TODO		Possible refactor functionality with validation
	 */
	runValidationOnPageNext : true,

	/**
	 * Add an unload handler to warn the user of potential loss of data
	 */
	warnOnUnload: true,
	 
	/**
	 * custom 'Page Next' event handler (to be overridden) 
     * @param	{HTMLElement}	elem	new page
	 */
	 onPageNext: function() {},
	 
	/**
	 * custom 'Page Previous' event handler (to be overridden) 
     * @param	{HTMLElement}	elem	new page
	 */
	 onPagePrevious: function() {}, 
	 
	 /**
	 * custom 'Page Change' event handler (either next or previous) (to be overridden) 
     * @param	{HTMLElement}	elem	new page
	 */
	 onPageChange: function() {}, 
	   
	/**
	 * Creates new instance of the behavior
     * @param	{HTMLElement}	f	Form element
     * @constructor
	 */
	instance: function(f) {
		this.behavior = wFORMS.behaviors.paging; 
		this.target = f;
		this.currentPageIndex = 1;
	}
}

/**
 * Factory Method.
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
wFORMS.behaviors.paging.applyTo = function(f) {
	var b = null;
	var behavior = wFORMS.behaviors.paging;
	var isValidationAccepted = (wFORMS.behaviors.validation && wFORMS.behaviors.paging.runValidationOnPageNext);
	
	
	// Iterates over the elements with specified class names
	f.querySelectorAll(wFORMS.behaviors.paging.SELECTOR).forEach(
		function(elem){
			if(!b) {
				b = new wFORMS.behaviors.paging.instance(f)
			}			
			// Creates placeholder for buttons
			var ph = b.getOrCreatePlaceHolder(elem);
			var index = wFORMS.behaviors.paging.getPageIndex(elem);
			// If first page add just Next button
			if(index == 1){
				var ctrl = base2.DOM.bind(ph.appendChild(behavior._createNextPageButton(index)));
				
				if(isValidationAccepted){					
					ctrl.addEventListener('click', function(event) {							
							var v = wFORMS.getBehaviorInstance(b.target,'validation'); 
							if(v.run(event, elem)){b.run(event, ctrl);} 
						}, 
						false);					
				}else{
					ctrl.addEventListener('click', function(event) { b.run(event, ctrl); }, false);
				}

				wFORMS.behaviors.paging.showPage(elem);
			}else{
				// Adds previous button
				var ctrl = base2.DOM.bind(behavior._createPreviousPageButton(index));
				ph.insertBefore(ctrl, ph.firstChild);

				ctrl.addEventListener('click', function(event) { b.run(event, ctrl)}, false);

				// If NOT last page adds next button also
				if(!wFORMS.behaviors.paging.isLastPageIndex(index, true)){
					var _ctrl = base2.DOM.bind(ph.appendChild(behavior._createNextPageButton(index)));

					if(isValidationAccepted){						
						_ctrl.addEventListener('click', function(event) {
							var v = wFORMS.getBehaviorInstance(b.target,'validation'); 							 
							if(v.run(event, elem)){b.run(event, _ctrl);} 
						}, false);
					}else{
						_ctrl.addEventListener('click', function(event) { b.run(event, _ctrl); }, false);
					}
				}
			}
		}
	);
	// Looking for the first active page from 0. 0 is a "fake page"
	if(b){		
		p = b.findNextPage(0);
		b.currentPageIndex = 0;
		b.activatePage(wFORMS.behaviors.paging.getPageIndex(p), false); // no scrolling to the top of the page here
	
		// Add a unload handler to prevent accidental loss of data when navigating away from the page
		if(!window.onbeforeunload) {	
			window.onbeforeunload = function() { 
				if(b.behavior.warnOnUnload)
					return b.behavior.MESSAGES.CAPTION_UNLOAD;
				// don't return anything to skip the warning 
			};
		}
		b.onApply();	
		
		// intercept the submit event
		base2.DOM.Element.addEventListener(f, 'submit', function (e) {b.onSubmit(e, b)});	
	}
	return b;
}

/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
wFORMS.behaviors.paging.instance.prototype.onApply = function() {}

/** On submit advance the page instead, until the last page. */
wFORMS.behaviors.paging.instance.prototype.onSubmit = function (e, b) {
	if (!wFORMS.behaviors.paging.isLastPageIndex(b.currentPageIndex)) {
		var currentPage = wFORMS.behaviors.paging.getPageByIndex(b.currentPageIndex);
		var nextPage = b.findNextPage(b.currentPageIndex);
		
		// validate and advance the page
		var v = wFORMS.getBehaviorInstance(b.target, 'validation');
		if (v.run(e, currentPage)) {
			b.activatePage(b.currentPageIndex + 1);
			
			// focus the first form element in the next page
			var first = base2.DOM.Element.querySelector(nextPage, 'input, textarea, select');
			if (first) {
				first.focus();
			}
		}
		
		e.stopPropagation();
		e.preventDefault();
		e.pagingStopPropagation = true;
	}
	else {
		if(window.onbeforeunload) {
			window.onbeforeunload = null;
		}
}
}

/**
 * instance-specific pageNext event handler (can be overriden).
 * @param	{HTMLElement}	page element 
 */ 
wFORMS.behaviors.paging.instance.prototype.onPageNext = function(p) { this.behavior.onPageNext(p); }

/** 
 * instance-specific pagePrevious event handler (can be overriden).
 * @param	{HTMLElement}	page element 
 */ 
wFORMS.behaviors.paging.instance.prototype.onPagePrevious = function(p) { this.behavior.onPagePrevious(p); }

/** 
 * instance-specific pageChange event handlers (can be overriden).
 * @param	{HTMLElement}	page element 
 */ 
 wFORMS.behaviors.paging.instance.prototype.onPageChange = function(p) { this.behavior.onPageChange(p);}


/**
 * Returns page index by the page area element
 * @param	{HTMLElement}	elem
 * @return	{Integer}	or false
 */
wFORMS.behaviors.paging.getPageIndex = function(elem){
	if(elem && elem.id){
		var index = elem.id.replace(
			new RegExp(wFORMS.behaviors.paging.ID_PAGE_PREFIX + '(\\d+)'), "$1");

		index = parseInt(index);
		return !isNaN(index) ? index : false;

	}

	return false;
}

/**
 * Check if the given element is in the visible page.
 * @param	{DOMElement}	an element (such as a field to be validated)
 * @return	{boolean}
 */
wFORMS.behaviors.paging.isElementVisible = function(element){	
	while(element && element.tagName != 'BODY'){
		if(element.className) {
			if(element.className.indexOf(this.CSS_CURRENT_PAGE) != -1) {
				return true;
			}
			if(element.className.indexOf(this.CSS_PAGE) != -1 ) {
				return false;
			}
		} 
		element = element.parentNode;
	}	
	return true;
}

/**
 * Private method for creating button. Uses public method for design creating
 * @param	{Integer}	index 	Index of the page button belongs to
 * @return	{HTMLElement}
 * @private
 * @see wFORMS.behaviors.paging.createNextPageButton
 */
wFORMS.behaviors.paging._createNextPageButton = function(index){
	var elem = this.createNextPageButton();
	elem.setAttribute(this.ATTR_INDEX, index + 1);
	elem.id = this.ID_BUTTON_NEXT_PREFIX + index;
	return elem;
}

/**
 * Creates button for moving to the next page. This method could be overridden
 * And developed for easily customization for users. Behavior uses private method
 * @return	{HTMLElement}
 * @public
 */
wFORMS.behaviors.paging.createNextPageButton = function(){
	var elem = document.createElement('input'); 
	elem.setAttribute('value', this.MESSAGES.CAPTION_NEXT);
	elem.type = 'button';
	elem.className = this.CSS_BUTTON_NEXT;
	return elem;
}

/**
 * Private method for creating button. Uses public method for design creating
 * @param	{Integer}	index 	Index of the page button belongs to
 * @return	{HTMLElement}
 * @private
 * @see wFORMS.behaviors.paging.createPreviousPageButton
 */
wFORMS.behaviors.paging._createPreviousPageButton = function(index){
	var elem = this.createPreviousPageButton();
	elem.setAttribute(this.ATTR_INDEX, index - 1);
	elem.id = this.ID_BUTTON_PREVIOUS_PREFIX + index;;
	return elem;
}

/**
 * Creates button for moving to the next page. This method could be overridden
 * And developed for easily customization for users. Behavior uses private method
 * @return	{HTMLElement}
 * @public
 */
wFORMS.behaviors.paging.createPreviousPageButton = function(){
	var elem = document.createElement('input'); 
	elem.setAttribute('value', this.MESSAGES.CAPTION_PREVIOUS);
	elem.type = 'button';
	elem.className = this.CSS_BUTTON_PREVIOUS;
	return elem;
}

/**
 * Creates place holder for buttons
 * @param	{HTMLElement}	pageElem	Page where placeholder should be created
 * @return	{HTMLElement}
 */
wFORMS.behaviors.paging.instance.prototype.getOrCreatePlaceHolder = function(pageElem){
	var id = pageElem.id + this.behavior.ID_PLACEHOLDER_SUFFIX;
	var elem = document.getElementById(id);

	if(!elem){
		elem = pageElem.appendChild(document.createElement('div'));
		elem.id = id;
		elem.className = this.behavior.CSS_BUTTON_PLACEHOLDER;
	}	

	return elem;
}

/**
 * Hides page specified
 * @param	{HTMLElement}	e
 */
wFORMS.behaviors.paging.hidePage = function(e){
	if(e) {
		if(!e.removeClass) { // no base2.DOM.bind to speed up function 
			e.removeClass = function(className) { return base2.DOM.HTMLElement.removeClass(this,className) };
		}
		if(!e.addClass) { // no base2.DOM.bind to speed up function 
			e.addClass = function(className) { return base2.DOM.HTMLElement.addClass(this,className) };
		}
		e.removeClass(wFORMS.behaviors.paging.CSS_CURRENT_PAGE);
		e.addClass(wFORMS.behaviors.paging.CSS_PAGE);
	}
}

/**
 * Shows page specified
 * @param	{HTMLElement}	e
 */
wFORMS.behaviors.paging.showPage = function(e){
	if(e) {
		if(!e.removeClass) { // no base2.DOM.bind to speed up function 
			e.removeClass = function(className) { return base2.DOM.HTMLElement.removeClass(this,className) };
		}
		e.removeClass(wFORMS.behaviors.paging.CSS_PAGE);
		if(!e.addClass) { // no base2.DOM.bind to speed up function 
			e.addClass = function(className) { return base2.DOM.HTMLElement.addClass(this,className) };
		}
		e.addClass(wFORMS.behaviors.paging.CSS_CURRENT_PAGE);
	}
}

/**
 * Activates page by index
 * @param	{Integer}	index	
 * @param	{Boolean}	[optional] scroll to the top of the page (default to true)
 */
wFORMS.behaviors.paging.instance.prototype.activatePage = function(index /*, scrollIntoView*/){
	
	if(arguments.length>1) {
		var scrollIntoView = arguments[1];
	} else {
		var scrollIntoView = true;
	}
	
	if(index == this.currentPageIndex){
		return false;
	}
	index = parseInt(index);
	if(index > this.currentPageIndex){
		var p = this.findNextPage(this.currentPageIndex);
	} else {
		var p = this.findPreviousPage(this.currentPageIndex);
	}
	
	if(p) { 
		// Workaround for Safari. Otherwise it crashes with Safari 1.2
		var _self = this;
	//	setTimeout(
		//	function(){
				var index = _self.behavior.getPageIndex(p);
				_self.setupManagedControls(index);
				_self.behavior.hidePage(_self.behavior.getPageByIndex(_self.currentPageIndex));				
				_self.behavior.showPage(p);
				var  _currentPageIndex = _self.currentPageIndex;
				_self.currentPageIndex = index;
				
				// go to top of the page
				if (scrollIntoView) {
					if (p.scrollIntoView) {
						p.scrollIntoView();
					}
					else {
						location.hash = "#" + wFORMS.behaviors.paging.ID_PAGE_PREFIX + index;
					}
				}
				
				// run page change event handlers
				_self.onPageChange(p);
				if(index > _currentPageIndex){
					_self.onPageNext(p);
				} else {
					_self.onPagePrevious(p);
				}
		//	}, 1
		//);
	}
}

/**
 * Setups managed controls: Next/Previous/Send buttons
 * @param	{int}	index	Index of the page to make controls setting up. If null setups current page
 */
wFORMS.behaviors.paging.instance.prototype.setupManagedControls = function(index){
	// new 
	if(!index){
		index = this.currentPageIndex;
	}
	
	// new
	var b = wFORMS.behaviors.paging;
	if(b.isFirstPageIndex(index)){
		if(ctrl = b.getPreviousButton(index)){
			ctrl.style.visibility = 'hidden';
		}
	}else{
		if(ctrl = b.getPreviousButton(index)){
			ctrl.style.visibility = 'visible';
		}
	}

	if(b.isLastPageIndex(index)){
		if(ctrl = b.getNextButton(index)){
			ctrl.style.visibility = 'hidden';
		}
		this.showSubmitButtons();
	} else {
		if(ctrl = b.getNextButton(index)){
			ctrl.style.visibility = 'visible';
		}
		this.hideSubmitButtons();
	}
}

/**
 * Shows all submit buttons
 */
wFORMS.behaviors.paging.instance.prototype.showSubmitButtons = function(){
	var nl = this.target.getElementsByTagName('input');
	for(var i=0;i<nl.length;i++) {
		if(nl[i].type=='submit') {
			nl[i].className = nl[i].className.replace(new RegExp("(^|\\s)" + this.behavior.CSS_SUBMIT_HIDDEN + "(\\s|$)", "g"), "$2");
		}	
	}
}

/**
 * Hides all submit button
 */
wFORMS.behaviors.paging.instance.prototype.hideSubmitButtons = function(){
	var nl = this.target.getElementsByTagName('input');
	for(var i=0;i<nl.length;i++) {
		if(nl[i].type=='submit') {
			if(!(new RegExp("(^|\\s)" + this.behavior.CSS_SUBMIT_HIDDEN + "(\\s|$)")).test(nl[i].className)) {
				nl[i].className+=' '+this.behavior.CSS_SUBMIT_HIDDEN;
			}
		}
	}
}

/**
 * Returns page element specified by index
 * @param	{Integer}	index
 * @return	{HTMLElement}
 */
wFORMS.behaviors.paging.getPageByIndex = function(index){
	var page = document.getElementById(wFORMS.behaviors.paging.ID_PAGE_PREFIX + index);
	return page ? base2.DOM.bind(page) : false;
}

/**
 * Returns next button specified by index
 * @param	{int}	index	Index of the page button related to
 * @return	{HTMLElement}
 */
wFORMS.behaviors.paging.getNextButton = function(index){
	// base2 is not using here because of when control is absen it produces an error in IE
	// for example on last page there is not Next button, on first - Previous
	return document.getElementById(wFORMS.behaviors.paging.ID_BUTTON_NEXT_PREFIX + index);
}

/**
 * Returns previous button specified by index
 * @param	{int}	index	Index of the page button related to
 * @return	{HTMLElement}
 */
wFORMS.behaviors.paging.getPreviousButton = function(index){
	// base2 is not using here because of when control is absen it produces an error in IE
	// for example on last page there is not Next button, on first - Previous
	return document.getElementById(wFORMS.behaviors.paging.ID_BUTTON_PREVIOUS_PREFIX + index);
}

/**
 * Check if index passed is index of the last page
 * @param	{Integer}	index
 * @param	{bool}	ignoreSwitch	Ingoneres switch behavior when checking for last index
 * @return	{bool}
 */
wFORMS.behaviors.paging.isLastPageIndex = function(index, ignoreSwitch){
	index = parseInt(index) + 1;
	var b = wFORMS.behaviors.paging;
	var p = b.getPageByIndex(index);

	if((_b = wFORMS.behaviors['switch']) && !ignoreSwitch){
		while(p && _b.isSwitchedOff(p)){
			index++;
			p = b.getPageByIndex(index);
		}
	}

	return p ? false : true;
}

/**
 * Check if index passed is index of the first page
 * @param	{Integer}	index
 * @param	{bool}	ignoreSwitch	Ingoneres switch behavior when checking for first index
 * @return	{bool}
 */
wFORMS.behaviors.paging.isFirstPageIndex = function(index, ignoreSwitch){
	index = parseInt(index) - 1;
	var b = wFORMS.behaviors.paging;
	var p = b.getPageByIndex(index);
	if((_b = wFORMS.behaviors['switch']) && !ignoreSwitch){
		while(p && _b.isSwitchedOff(p)){
			index--;
			p = b.getPageByIndex(index);
		}
	}

	return p ? false : true;
}

/**
 * Returns Next page from the index. Takes in attention switch behavior
 * @param	{int}	index
 */
wFORMS.behaviors.paging.instance.prototype.findNextPage = function(index){
	index = parseInt(index) + 1;
	var b = wFORMS.behaviors.paging;
	var p = b.getPageByIndex(index);

	if(_b = wFORMS.behaviors['switch']){
		while(p && _b.isSwitchedOff(p)){
			index++;
			p = b.getPageByIndex(index);
		}
	}
	return p;
}

/**
 * Returns Next page from the index. Takes in attention switch behavior
 * @param	{int}	index
 */
wFORMS.behaviors.paging.instance.prototype.findPreviousPage = function(index){
	index = parseInt(index) - 1;
	var b = wFORMS.behaviors.paging;
	var p = b.getPageByIndex(index);

	if(_b = wFORMS.behaviors['switch']){
		while(p && _b.isSwitchedOff(p)){
			index--;
			p = b.getPageByIndex(index);
		}
	}

	return p ? p : false;
}





/**
 * Executes the behavior
 * @param {event} e 
 * @param {domElement} element
 */
wFORMS.behaviors.paging.instance.prototype.run = function(e, element){
	this.activatePage(element.getAttribute(wFORMS.behaviors.paging.ATTR_INDEX));
}

	
if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms repeat behavior. 
 * See: http://www.formassembly.com/wForms/v2.0/documentation/examples/repeat.html
 */
wFORMS.behaviors.repeat = {

	/**
	 * Selector expression for catching repeat elements
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/
	 */
	SELECTOR_REPEAT : '*[class~="repeat"]',

	/**
	 * Selector expression for catching removable section
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/
	 */
	SELECTOR_REMOVEABLE : '*[class~="removeable"]',

	/**
	 * Suffix for the ID of 'repeat' link
     * @final
	 */
	ID_SUFFIX_DUPLICATE_LINK : '-wfDL',

	/**
	 * Suffix for the ID of the repeat counter hidden element
     * @final
	 */
	ID_SUFFIX_COUNTER : '-RC',

	/**
	 * CSS class for duplicate span/link
     * @final
	 */
	CSS_DUPLICATE_LINK : 'duplicateLink',
	CSS_DUPLICATE_SPAN : 'duplicateSpan',
	/**
	 * CSS class for delete link
     * @final
	 */
	CSS_DELETE_LINK : 'removeLink',
	CSS_DELETE_SPAN : 'removeSpan',
	/**
	 * CSS class for field group that could be removed
     * @final
	 */
	CSS_REMOVEABLE : 'removeable',

	/**
	 * CSS class for field group that could be repeat
     * @final
	 */
	CSS_REPEATABLE : 'repeat',

	/**
	 * Attribute specifies that current group is duplicate
     * @final
	 */
	ATTR_DUPLICATE : 'wfr__dup',

	/**
	 * Attribute specifies that current group is duplicate
     * @final
	 */
	ATTR_DUPLICATE_ELEM : 'wfr__dup_elem',


    /**
     * Means that element has been already handled by repeat behavior
     */
	ATTR_HANDLED : 'wfr_handled',

	/**
	 * Attribute specifies ID of the master section on its dublicate
     * @final
	 */
	ATTR_MASTER_SECTION : 'wfr__master_sec',

	/**
	 * Special attribute name that is set to Remove link with section ID
     * should be deleted when link is clicked
     * @final
	 */
	ATTR_LINK_SECTION_ID : 'wfr_sec_id',

	/**
	 * Messages collection used for creating links
     * @final
	 */
	MESSAGES : {
		ADD_CAPTION : "Add another response",
		ADD_TITLE : "Will duplicate this question or section.",

		REMOVE_CAPTION : "Remove",
		REMOVE_TITLE : "Will remove this question or section"
	},

	/**
	 * Array of the attribute names that shoud be updated in the duplicated tree
	 */
	UPDATEABLE_ATTR_ARRAY : [
		'id',
		'name',
		'for'
	],

	/**
	 * Allows to leave names of the radio buttons the same (behavior-wide setting)
	 */
	preserveRadioName : false,
	
	/**
	 * Allows to leave names of the radio buttons the same (field-level setting)
	 * This class attribute can be set on a repeated element to override the
	 * behavior's preserveRadioName setting.
	 */
	CSS_PRESERVE_RADIO_NAME: "preserveRadioName",
	
	/**
	 * Custom function that could be overridden. 
	 * Evaluates after section is duplicated
     * @param	{HTMLElement}	elem	Duplicated section
	 */
	onRepeat : function(elem){},

	/**
	 * Custom function that could be overridden. 
	 * Evaluates after the section is removed
	 * @param	{HTMLElement}	elem	a copy of the removed section - detached from the document
	 */
	onRemove : function(elem){},

	/**
	 * Custom function that could be overridden. 
	 * Returns if section could be repeated
     * @param	{HTMLElement}	elem	Section to be duplicated
     * @param	{wFORMS.behaviors.repeat}	b	Behavior mapped to repeatable section 
     * @return	boolean
	 */
	allowRepeat : function(elem, b){
		return true;
	},

	/**
	 * Creates new instance of the behavior
     * @param	{HTMLElement}	f	Form element
     * @constructor
	 */
	instance : function(f) {
		this.behavior = wFORMS.behaviors.repeat; 
		this.target = f;		
	}
}

/*
 * Temporary shortcuts
 */
var _b = wFORMS.behaviors.repeat;
var _i = wFORMS.behaviors.repeat.instance;

/**
 * Factory Method.
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
_b.applyTo = function(f) {
	// look up for the all elements that could be repeated.
	// Trying to add event listeners to elements for adding new container.
	// If need create Add new section element
	var _self = this;
	var b = new Array();

	if(!f.querySelectorAll){base2.DOM.bind(f);}
	
	if(wFORMS.behaviors.repeat.getMasterSection(f)){
		var masterArray = Array();
		var masterSection = wFORMS.behaviors.repeat.getMasterSection(f);
			if(!masterSection.querySelectorAll){base2.DOM.bind(masterSection);}
			
		var masterNodes = masterSection.querySelectorAll(this.SELECTOR_REPEAT);
			masterNodes.forEach(function(elem){
				masterArray.push(elem.querySelector(".duplicateLink").innerHTML);
			});
	}	
	
	f.querySelectorAll(this.SELECTOR_REPEAT).forEach(
		function(elem,index){ 
			if(_self.isHandled(elem)){
				return ;
			}
			if(!elem.id) elem.id = wFORMS.helpers.randomId();
			
			var _b = new _self.instance(elem);
			if(masterArray && masterArray[index]){
				_b.behavior.MESSAGES.ADD_CAPTION = masterArray[index];
			}
			var e = _b.getOrCreateRepeatLink(elem);
			e.addEventListener('click', function(event) { _b.run(event, e)}, false);
			_b.setElementHandled(elem);
			b.push(_b);							
		}
	);
	
	if(!f.hasClass) {
		f.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
	}
	
	if(f.hasClass(this.CSS_REMOVEABLE)){
		var m  = this.getMasterSection(f);		
		var _i = wFORMS.getBehaviorInstance(m, 'repeat');
		if(_i) {
			_i.getOrCreateRemoveLink(f);
		} else if(b[0]){
			b[0].getOrCreateRemoveLink(f);
		}
	}
	
	f.querySelectorAll(this.SELECTOR_REMOVEABLE).forEach(function(e){
		var m  = wFORMS.behaviors.repeat.getMasterSection(e);
		var _i = wFORMS.getBehaviorInstance(m, 'repeat');
		if(_i) {
			_i.getOrCreateRemoveLink(e);
		} else if(b[0]){
			b[0].getOrCreateRemoveLink(e);
		}
	});
	
	for(var i=0;i<b.length;i++) {
		b[i].onApply();
	}
	return b;
}

/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
_i.prototype.onApply = function() {} 


/**
 * Returns repeat link for specified area if it exists, 
 * otherwise creates new one and returns it
 * @param	{HTMLElement}	elem	Element repeat link is related to
 * @return	{HTMLElement}
 */
_i.prototype.getOrCreateRepeatLink = function(elem){
	var id = elem.id + this.behavior.ID_SUFFIX_DUPLICATE_LINK;
	var e = document.getElementById(id);
	if(!e || e == ''){
		e = this.createRepeatLink(id);
		
		// Wraps in a span for better CSS positionning control.
		var spanElem = document.createElement('span');
		spanElem.className = this.behavior.CSS_DUPLICATE_SPAN;
		e = spanElem.appendChild(e);
		
		if(elem.tagName.toUpperCase() == 'TR'){
			var tdElem = elem.getElementsByTagName('TD');
			if(!tdElem){
				tdElem = elem.appendChild(document.createElement('TD'));
			} else {
				tdElem = tdElem[tdElem.length-1]; 
			}
			tdElem.appendChild(spanElem);
		}else{
			elem.appendChild(spanElem);
			// elem.parentNode.insertBefore(spanElem, elem.nextSibling);
		}
	}
	return base2.DOM.bind(e);
}

/**
 * Returns repeat link for specified area if it exists, 
 * otherwise creates new one and returns it
 * @param	{DOMString}	id	ID of the group
 * @return	{HTMLElement}
 */
_i.prototype.createRepeatLink = function(id){
	// Creates repeat link element
	var linkElem = document.createElement("A");
				
	linkElem.id = id;
	linkElem.setAttribute('href', '#');	
	linkElem.className = this.behavior.CSS_DUPLICATE_LINK;
	linkElem.setAttribute('title', this.behavior.MESSAGES.ADD_TITLE);	

	// Appends text inside the <span element (for CSS replacement purposes) to <a element
	linkElem.appendChild(document.createElement('span').appendChild(
		document.createTextNode(this.behavior.MESSAGES.ADD_CAPTION)));

	return linkElem;
}

/*
 * Add remove link to duplicated section
 * @param 	{DOMElement}	duplicated section.
 */ 	
_i.prototype.getOrCreateRemoveLink= function(elem){
	var e  = this.createRemoveLink(elem.id);
	// looking for the place where to paste link
	if(elem.tagName == 'TR'){
		var tds = elem.getElementsByTagName('TD');
		var tdElem = tds[tds.length-1];
		tdElem.appendChild(e);
	} else {
		elem.appendChild(e)
	}
}

/**
 * Returns remove link for specified area 
 * @param	{DOMString}	id	ID of the field group
 * @return	{HTMLElement}
 */
_i.prototype.createRemoveLink = function(id){
	// Creates repeat link element
	var linkElem = document.createElement("a");
	
	linkElem.id = id + this.behavior.ID_SUFFIX_DUPLICATE_LINK;
	linkElem.setAttribute('href', '#');	
	linkElem.className = this.behavior.CSS_DELETE_LINK;
	linkElem.setAttribute('title', this.behavior.MESSAGES.REMOVE_TITLE);	
	linkElem.setAttribute(this.behavior.ATTR_LINK_SECTION_ID, id);

	// Appends text inside the <span element (for CSS image replacement) to <a element
	var spanElem = document.createElement('span');
	spanElem.appendChild(document.createTextNode(this.behavior.MESSAGES.REMOVE_CAPTION));
	linkElem.appendChild(spanElem);

	var _self = this;
	linkElem.onclick = function(event) { _self.onRemoveLinkClick(event, linkElem); return false; };	

	// Wraps in a span for better CSS positionning control.
	var spanElem = document.createElement('span');
	spanElem.className = this.behavior.CSS_DELETE_SPAN;
	spanElem.appendChild(linkElem);
	
	return spanElem;
}


/**
 * Duplicates repeat section. Changes ID of the elements, adds event listeners
 * @param	{HTMLElement}	elem	Element to duplicate
 */
_i.prototype.duplicateSection = function(elem){
	// Call custom function. By default return true
	if(!this.behavior.allowRepeat(elem, this)){
		return false;
	}
	this.updateMasterSection(elem);
	// Creates clone of the group
	var newElem = elem.cloneNode(true);
		
	// Update the ids, names and other attributes that must be changed.
	// (do it before inserting the element back in the DOM to prevent reseting radio buttons, see bug #152)
	var index  = this.getNextDuplicateIndex(this.target);
	var suffix = this.createSuffix(elem, index);

	this.updateDuplicatedSection(newElem, index, suffix);
	// Insert in DOM		
	newElem = elem.parentNode.insertBefore(newElem, this.getInsertNode(elem));
	
	wFORMS.applyBehaviors(newElem);
		/*
	// Associates repeated input sections with their calculations.
	if(wFORMS.behaviors.calculation) {
		_c = wFORMS.behaviors.calculation;
		inputItem = newElem.querySelector('input');
		if(inputItem) {
			if(inputItem.className.search(_c.VARIABLE_SELECTOR_PREFIX) != -1) {
//				var b1 = wFORMS.getBehaviorInstance(inputItem.form,'calculation');
				console.log('repeat applyto');
				var b2 =_c.applyTo(inputItem.form);
//				console.log(b2);
			}
		}
	}
	*/
	// Calls custom function
	this.behavior.onRepeat(newElem);
	
	wFORMS.helpers.spotlight(newElem);
}

/**
 * Removes section specified by id
 * @param	{DOMElement}	element to remove
 */
_i.prototype.removeSection = function(elem){
	if(elem){
		// Removes section
		var elem = elem.parentNode.removeChild(elem);
		// Calls custom function
		this.behavior.onRemove(elem);
	}
}
/**
 * Looking for the place where to insert the cloned element
 * @param 	{DOMElement} 	source element
 * @return 	{DOMElement} 	target element for 'insertBefore' call.
 */
_i.prototype.getInsertNode = function(elem) {
 	var insertNode = elem.nextSibling;
 	
 	if(insertNode && insertNode.nodeType==1 && !insertNode.hasClass) {
		insertNode.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
	}
  	
	while(insertNode && 
		 (insertNode.nodeType==3 ||       // skip text-node that can be generated server-side when populating a previously repeated group 
		  insertNode.hasClass(this.behavior.CSS_REMOVEABLE))) {						
		
		insertNode = insertNode.nextSibling;
		
		if(insertNode && insertNode.nodeType==1 && !insertNode.hasClass) {
			insertNode.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
		}
	}
	return insertNode;
}
/**
 * Evaluates when user clicks Remove link
 * @param	{DOMEvent}		Event	catched
 * @param	{HTMLElement}	elem	Element produced event
 */
_i.prototype.onRemoveLinkClick = function(event, link){
	var e  = document.getElementById(link.getAttribute(this.behavior.ATTR_LINK_SECTION_ID));
	this.removeSection(e);
	if(event) event.preventDefault();
}

/**
 * Updates attributes inside the master element
  * @param	{HTMLElement}	elem
 */
_i.prototype.updateMasterSection = function(elem){
	// do it once 
	if(elem.doItOnce==true) {		
		return true;
	} else {
		elem.doItOnce=true;
	}
	var suffix = this.createSuffix(elem);
	elem.id = this.clearSuffix(elem.id) + suffix;
	
	this.updateMasterElements(elem, suffix);
}
_i.prototype.updateMasterElements  = function(elem, suffix){
	
	if(!elem || elem.nodeType!=1) 
		return;
	
	var cn = elem.childNodes;
	for(var i=0;i<cn.length;i++) {
		var n = cn[i];
		if(n.nodeType!=1) continue;
		
		if(!n.hasClass) { // no base2.DOM.bind to speed up function 
			n.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
		}
		
		// suffix may change for this node and child nodes, but not sibling nodes, so keep a copy
		var siblingSuffix = suffix;
		if(n.hasClass(this.behavior.CSS_REPEATABLE)) {
			suffix += "[0]";
		}
		if(!n.hasClass(this.behavior.CSS_REMOVEABLE)){
			// Iterates over updateable attribute names
			for(var j = 0; j < this.behavior.UPDATEABLE_ATTR_ARRAY.length; j++){
				var attrName = this.behavior.UPDATEABLE_ATTR_ARRAY[j];
				var value = this.clearSuffix(n.getAttribute(attrName));
				if(!value){
					continue;
				}				
				if(attrName=='id' && wFORMS.behaviors.hint && wFORMS.behaviors.hint.isHintId(n.id)){
					n.id = value.replace(new RegExp("(.*)(" + wFORMS.behaviors.hint.HINT_SUFFIX + ')$'),"$1" + suffix + "$2");
				} else if(attrName=='id' && wFORMS.behaviors.validation && wFORMS.behaviors.validation.isErrorPlaceholderId(n.id)){
					n.id = value.replace(new RegExp("(.*)(" + wFORMS.behaviors.validation.ERROR_PLACEHOLDER_SUFFIX + ')$'),"$1" + suffix + "$2"); 
				} else if(attrName=='id' && n.id.indexOf(this.behavior.ID_SUFFIX_DUPLICATE_LINK) != -1){
					n.id = value.replace(new RegExp("(.*)(" + this.behavior.ID_SUFFIX_DUPLICATE_LINK + ')$'), "$1" + suffix + "$2");
				} else if(attrName=='id'){ 
					n.id = value + suffix;		// do not use setAttribute for the id property (doesn't work in IE6)	
				} else if(attrName=='name'){ 
					n.name = value + suffix;	// do not use setAttribute for the name property (doesn't work in IE6)	
				} else {
					n.setAttribute(attrName, value + suffix);	
				}
			}			
			this.updateMasterElements(n, suffix);
		}
		// restore suffix for siblings if needed.
		suffix = siblingSuffix;
	}
}

/**
 * Updates attributes inside the duplicated tree
 * TODO rename
 * @param	{HTMLElement}	dupliocated element (not yet inserted back in DOM)
 * @param	{integer}		row index
 * @param	{string}		array-like notation, to be appended to attributes that must be unique.
 */
_i.prototype.updateDuplicatedSection = function(elem, index, suffix){
	
	// Caches master section ID in the dublicate
	elem[this.behavior.ATTR_MASTER_SECTION]=elem.id;
		
	// Updates element ID (possible problems when repeat element is Hint or switch etc)
	elem.id = this.clearSuffix(elem.id) + suffix;
	// Updates classname	
	elem.className = elem.className.replace(this.behavior.CSS_REPEATABLE, this.behavior.CSS_REMOVEABLE);

	if(!elem.hasClass) { // no base2.DOM.bind to speed up function 
		elem.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
	}
	// Check for preserverRadioName override
	if(elem.hasClass(this.behavior.CSS_PRESERVE_RADIO_NAME)) 
		var _preserveRadioName = true;
	else
		var _preserveRadioName = this.behavior.preserveRadioName;
		
	this.updateSectionChildNodes(elem, suffix, _preserveRadioName);
}


/**
 * Updates NodeList. Changes ID and names attributes
 * For different node elements suffixes could be different - i.e. for the nested
 * repeat section IDs and names should store parent section number
 * @param	elems	Array of the elements should be updated
 * @param	suffix	Suffix value should be added to attributes
 */
_i.prototype.updateSectionChildNodes = function(elem, suffix, preserveRadioName){
	
	/* Fix for Ticket #256 - id of nested repeated element not set properly */
	if(elem.doItOnce) {		
		elem.doItOnce = null;		
	}
	
	var removeStack = new Array();
	var i = 0;
	
	while(elem && elem.childNodes && elem.childNodes[i]) {
	
		var e = elem.childNodes[i];
		i++;
		
		if(e.nodeType!=1) {
			// skip text nodes 
			continue;
		}
		if(!e.hasClass) { // no base2.DOM.bind to speed up function 
			e.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
		}
		// Removes created descendant duplicated group if any
		if(this.behavior.isDuplicate(e)){
			removeStack.push(e);
			continue;
		}
		// Removes duplicate link
		if(e.hasClass(this.behavior.CSS_DUPLICATE_SPAN)){
			removeStack.push(e);
			continue;
		}
		if(e.hasClass(this.behavior.CSS_DUPLICATE_LINK)){
			removeStack.push(e);
			continue;
		}
				
		// Clears value	(TODO: select?)
		if((e.tagName == 'INPUT' && e.type != 'button') || e.tagName == 'TEXTAREA'){
			if(e.type != 'radio' && e.type != 'checkbox'){
				e.value = '';
			} else {
				e.checked = false;
			}
		}
		
		// Fix #152 - Radio name with IE6, IE7?
		if(e.tagName == 'INPUT' && e.type == 'radio' && !preserveRadioName && /*@cc_on @if(@_jscript_version < 5.8)! @end @*/false) {
				 
			// Create a radio input that works in IE and insert it before the input it needs to replace
			var tagHtml = "<INPUT type=\"radio\" name=\""+e.name+suffix+"\"></INPUT>";
			var fixedRadio = e.parentNode.insertBefore(document.createElement(tagHtml),e);
		
			// Clone other attributes
			fixedRadio.id = e.id;
			fixedRadio.className = e.className;
			fixedRadio.value = e.value;
			
			// Remove original radio (keep element in memory)
			e = e.parentNode.removeChild(e);			
							
			var l = this.behavior.UPDATEABLE_ATTR_ARRAY.length;
						
			for (var j = 0; j < l; j++) {			
				var attrName = this.behavior.UPDATEABLE_ATTR_ARRAY[j];
				var value = e.getAttribute(attrName);
				fixedRadio.setAttribute(attrName, value);	
			}			
			// We can now continue with the fixed radio element				
			e = fixedRadio;				
			if(!e.hasClass) { // no base2.DOM.bind to speed up function 
				e.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
			}								
		} 
		
		this.updateAttributes(e, suffix, preserveRadioName);
		
		if(e.hasClass(this.behavior.CSS_REPEATABLE)){
			this.updateSectionChildNodes(e, this.createSuffix(e), preserveRadioName);
		} else{
			this.updateSectionChildNodes(e, suffix, preserveRadioName);
		}
   	}   
	 
   	for(var i=0;i<removeStack.length;i++){
   		var e = removeStack[i];
   		if(e.clearAttributes) {
			// detach all event handler 
			e.clearAttributes(false); 	
		}
   		if(e.parentNode) e.parentNode.removeChild(e);
   	}
   
}

/**
 * Creates suffix that should be used inside duplicated repeat section
 * @param	domelement	Repeat section element
 * @param	integer		row index	
 */
_i.prototype.createSuffix = function(e, index){

	// var idx = e.getAttribute('dindex');
	var suffix = '[' + (index ? index : '0' ) + ']';
    var reg = /\[(\d+)\]$/;
	e = e.parentNode;
	while(e && e.tagName){
		if(!e.hasClass) { // no base2.DOM.bind to speed up function 
			e.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
		}
		if(e.hasClass(this.behavior.CSS_REPEATABLE) || e.hasClass(this.behavior.CSS_REMOVEABLE)){
			var idx = reg.exec(e.id);
			if(idx) idx = idx[1];
			//var idx = e.getAttribute('dindex');
			suffix = '[' + (idx ? idx : '0' ) + ']' + suffix;
		}
		e = e.parentNode;
	}
	return suffix;
}

/**
 * Removes row counters from ID
 * @param	id	Current element id
 * @return	string
 * 
 * repeated field ID is: 			fieldid[n]...[n]
 * repeated hint ID is:				fieldid[n]...[n]-H
 * repeated error placeholder is : 	fieldid[n]...[n]-E
 * returns fieldid, fieldid-H or fieldid-E
 */
_i.prototype.clearSuffix = function(value){
	if(!value){
		return;
	}	
    value = value.replace(/(\[\d+\])+(\-[HE])?$/,"$2");    
	return value;
}

/**
 * Updates attributes of the element in the section
 * TODO rename
 * @param	{HTMLElement}	elem
 */
_i.prototype.updateAttributes = function(e, idSuffix, preserveRadioName){
	var isHint = wFORMS.behaviors.hint && wFORMS.behaviors.hint.isHintId(e.id);
	var isErrorPlaceholder = wFORMS.behaviors.validation && wFORMS.behaviors.validation.isErrorPlaceholderId(e.id);
	var isDuplicateLink = e.id.indexOf(this.behavior.ID_SUFFIX_DUPLICATE_LINK) != -1;

	// Sets that element belongs to duplicate group
	this.setInDuplicateGroup(e);

	if(this.behavior.isHandled(e)){
		this.removeHandled(e)
	}

	if(wFORMS.behaviors['switch'] && wFORMS.behaviors['switch'].isHandled(e)){
		wFORMS.behaviors['switch'].removeHandle(e);
	}
	if(wFORMS.behaviors['calculation'] && wFORMS.behaviors['calculation'].isHandled(e)){
		wFORMS.behaviors['calculation'].removeHandledFlag(e);
	}
	// Iterates over updateable attribute names
	var l = this.behavior.UPDATEABLE_ATTR_ARRAY.length;
	for(var i = 0; i < l; i++){
		var attrName = this.behavior.UPDATEABLE_ATTR_ARRAY[i];
		
		var value = this.clearSuffix(e.getAttribute(attrName));	
		if(!value){
			continue;
		}

		if(attrName == 'name' && e.tagName == 'INPUT' && preserveRadioName){
			continue;
		} else if(isErrorPlaceholder && attrName=='id'){	
			e.id = value.replace(new RegExp("(.*)(" + wFORMS.behaviors.validation.ERROR_PLACEHOLDER_SUFFIX + ')$'),"$1" + idSuffix + "$2");
		} else if(isHint && attrName=='id'){			
			e.id = value.replace(new RegExp("(.*)(" + wFORMS.behaviors.hint.HINT_SUFFIX + ')$'),"$1" + idSuffix + "$2");
		} else if(isDuplicateLink && attrName=='id'){
			e.id = value.replace(new RegExp("(.*)(" + this.behavior.ID_SUFFIX_DUPLICATE_LINK + ')$'),"$1" + idSuffix + "$2");
		} else if(attrName=='id'){ 
			e.id = value + idSuffix;	// do not use setAttribute for the id property (doesn't work in IE6)	
		} else if(attrName=='name'){ 
			e.name = value + idSuffix;	// do not use setAttribute for the id property (doesn't work in IE6)	
		} else {
			e.setAttribute(attrName, value + idSuffix);	
		}
	}
}

/**
 * Returns index of the next created duplicate by section HTML element
 * @param	{HTMLElement}	elem
 * @return	{Integer}
 */
_i.prototype.getNextDuplicateIndex = function(elem){
	var c = this.getOrCreateCounterField(elem);
	var newValue = parseInt(c.value) + 1;
	c.value = newValue;
	return newValue;
}


/**
 * Returns counter field fo specified area if exists. Otherwise creates new one
 * @param	{HTMLElement}	elem
 * @return	{HTMLElement}
 */
_i.prototype.getOrCreateCounterField = function(elem){
		
	var cId = elem.id + this.behavior.ID_SUFFIX_COUNTER;
	
	// Using getElementById except matchSingle because of lib bug
	// when element is not exists exception is thrown
	var cElem = document.getElementById(cId);
	if(!cElem || cElem == ''){
		cElem = this.createCounterField(cId);
		// Trying to find form element
		var formElem = elem.parentNode;
		while(formElem && formElem.tagName.toUpperCase() != 'FORM'){
			formElem = formElem.parentNode;
		}

		formElem.appendChild(cElem);
	}
	return cElem;
}

/**
 * Creates counter field with specified ID
 * @param	{DOMString}	id
 * @return	{HTMLElement}
 */
_i.prototype.createCounterField = function(id){

	cElem = document.createElement('input');
	cElem.id = id;
	cElem.setAttribute('type', 'hidden');
	cElem.setAttribute('name', id);
	cElem.value = '0';
	return cElem;
}

/**
 * Returns count of already duplicated sections. If was called from the behavior 
 * belonged to duplicated section, returns false
 * @public
 * @return	{Integer} or {boolean}
 */
_i.prototype.getSectionsCount = function(){
	if(this.behavior.isDuplicate(this.target)){
		return false;
	}
	return parseInt(this.getOrCreateCounterField(this.target).value) + 1;
}

/**
 * Specifies that element is inside the duplicate group
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_i.prototype.setInDuplicateGroup = function(elem){
	return elem.setAttribute(this.behavior.ATTR_DUPLICATE_ELEM, true);
}


/**
 * setElementHandled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_i.prototype.setElementHandled = function(elem){
	return elem.setAttribute(this.behavior.ATTR_HANDLED, true);
}

/**
 * Remove handled attribute from element
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_i.prototype.removeHandled = function(elem){
	return elem.removeAttribute(this.behavior.ATTR_HANDLED);
}

/**
 * Returns true if element is duplicate of initial group, false otherwise
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_b.isDuplicate = function(elem){
		if(!elem.hasClass) { // no base2.DOM.bind to speed up function 
			elem.hasClass = function(className) { return base2.DOM.HTMLElement.hasClass(this,className) };
		}
	return elem.hasClass(this.CSS_REMOVEABLE);
}


/**
 * Returns true if element belongs to duplicate group
 * (to be used by other behaviors) 
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_b.isInDuplicateGroup = function(elem){
	return elem.getAttribute(this.ATTR_DUPLICATE_ELEM) ? true : false;
}


/**
 * Checks if element is already handled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
_b.isHandled = function(elem){
	return elem.getAttribute(this.ATTR_HANDLED);
}


/**
 * Returns html element of the master section (repeatable) from its duplicate
 * @param	{HTMLElement}	elem
 * @return	{HTMLElement} or false
 */
_b.getMasterSection = function(elem){
	if(!this.isDuplicate(elem)) return false;	
	return document.getElementById(elem[this.ATTR_MASTER_SECTION]);
}


/**
 * Executes the behavior
 * @param {event} e 
 */
_i.prototype.run = function(e){ 	
	
	if(!wFORMS.LOADER.enabled) {
		this.duplicateSection(this.target);
	} else {
		// run through timeout only if loader is enabled (breaks test suite otherwise)
		var self = this;
		wFORMS.LOADER.show(self.target);
		setTimeout( function() { 
			self.duplicateSection(self.target);
			wFORMS.LOADER.hide(self.target, true); 
		}, 1);
	}
	if(e) e.preventDefault();
}


if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms switch behavior.  
 * See: http://www.formassembly.com/wForms/v2.0/documentation/conditional-sections.php
 *  and http://www.formassembly.com/wForms/v2.0/documentation/examples/switch_validation.html 
 */
wFORMS.behaviors['switch']  = {

	/**
	 * Selector expression for the switch elements
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/

	 */
	SELECTOR : '*[class*="switch-"]',

	/**
	 * CSS class name prefix for switch elements
     * @final
	 */
	CSS_PREFIX : 'switch-',

	/**
	 * CSS class prefix for the off state of the target element
     * @final
	 */
	CSS_OFFSTATE_PREFIX : 'offstate-',

	/**
	 * CSS class prefix for the on state of the target element
     * @final
	 */
	CSS_ONSTATE_PREFIX : 'onstate-',
	
	/**
	 * CSS class for switch elements that don't have a native ON state (ie. links)
     * @final
	 */
	CSS_ONSTATE_FLAG : 'swtchIsOn',
	
	/**
	 * CSS class for switch elements that don't have a native OFF state (ie. links)
     * @final
	 */
	CSS_OFFSTATE_FLAG : 'swtchIsOff',
	
	/**
	 * Custom function that could be overridden. 
	 * Evaluates when an element is switched on
     * @param	{HTMLElement}	elem	Duplicated section
	 */
	onSwitchOn: function(elem){ 
	},
	
	/**
	 * Custom function that could be overridden. 
	 * Evaluates when an element is switched off
     * @param	{HTMLElement}	elem	Duplicated section
	 */
	onSwitchOff: function(elem){ 
	},
	
	/**
	 * Custom function that could be overridden. 
	 * Evaluates after a switch is triggered
	 * (after all onSwitchOn and onSwitchOff events)
     * @param	{HTMLElement}	elem	Duplicated section
	 */
	onSwitch: function(form){  
	},
	
	/**
	 * Creates new instance of the behavior
     * @constructor
	 */
	instance : function(f){
		this.behavior = wFORMS.behaviors['switch']; 
		this.target   = f;
		this.cache    = {};
	}
}

/**
 * Factory Method.
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
wFORMS.behaviors['switch'].applyTo = function(f){
	
	var b = new wFORMS.behaviors['switch'].instance(f);
	
	// Traverse dom tree and look for elements with the switch trigger or target classes. Store in cache object.
	b.buildCache();
	
	if(b.isCacheEmpty()) {
		// Nothing to do, bail out.
		b.onApply();
		return b;
	}
	
	// Add onchange/onclick event handlers to found triggers.
	b.setupTriggers();	
	
	// Check if behavior was applied on a form element. If not, we may need to merge behavior.
	// (This happens when behavior is applied to a repeated section) 
	if(f.tagName!='FORM') {	
		
		// Check if there's a parent form tag, with a switch behavior already set up.		
		while(f && f.tagName!='FORM') {
			f = f.parentNode;
		}		
		var _b = wFORMS.getBehaviorInstance(f,'switch');
		if(_b) {
			// Found existing instance of behavior on parent form element. 
			
			// Merge triggers+targets just found into existing behavior's cache. We'll discard the new behavior data once we're done here.
			_b.merge(b);
			
			// Copy cache back into new behavior so we can set up the targets correctly.
			b.cache = _b.cache;			
			b.setupTargets();	
			
			// Run 'onApply' hook.			
			b.onApply();
			
			// Discard the new behavior data by returning an empty behavior object.
			// (it's a workaround. Core doesn't check if the behavior returned already exists)
			return new Array({target:null}); 
		}				
	}	
	b.setupTargets();	
	b.onApply();
	
	return b;	
}

/**
 * Go through all triggers listed in the behavior cache and add event handlers.  
 */
wFORMS.behaviors['switch'].instance.prototype.setupTriggers = function() {
	for(var i in this.cache) {
		var triggers = this.cache[i].triggers;
		for(var j=0; j<triggers.length;j++) {
			this.setupTrigger(triggers[j]);
		} 
	}	
}

/**
 * Add event handler to trigger element.
 */	
wFORMS.behaviors['switch'].instance.prototype.setupTrigger = function(elem) {
	var self = this;
	if(!elem.id){
		elem.id = wFORMS.helpers.randomId()
	}
	
	switch(elem.tagName.toUpperCase()){
		case 'OPTION' : 
			var sNode = elem.parentNode;
			// Tries to get <select node
			while (sNode && sNode.tagName != 'SELECT'){
				sNode = sNode.parentNode;
			} 		
			if(sNode && !wFORMS.behaviors['switch'].isHandled(sNode)){
				sNode.addEventListener('change', function(event) { self.run(event, sNode) }, false);
				wFORMS.behaviors['switch'].handleElement(sNode);
			}
			break;
		case 'SELECT' :
			if(elem && !wFORMS.behaviors['switch'].isHandled(elem)){
				elem.addEventListener('change', function(event) { self.run(event, elem) }, false);
				wFORMS.behaviors['switch'].handleElement(elem);
			}
			break;		
		case 'INPUT' : 
			if(elem.type && elem.type.toUpperCase() == 'RADIO'){
				
				// Retreives all radio group
				var radioGroup = elem.form[elem.name];
				if(!radioGroup) {
					// repeated radio groups don't show up in the collection in IE6+
					radioGroup = [];
					var c = elem.form.getElementsByTagName('INPUT');
					for(var k=0;k<c.length;k++) {
						if(c[k].type=='radio' && c[k].name==elem.name) {
							radioGroup.push(c[k]);
						}
					}
				}
				for(var i=radioGroup.length-1;i>=0;i--) {
					
					var _elem = radioGroup[i];
					wFORMS.standardizeElement(_elem);	
					
					if(!this.behavior.isHandled(_elem)){
						_elem.addEventListener('click', function(event) { self.run(event, _elem) }, false);								
						this.behavior.handleElement(_elem);
					}
				}
			} else if(elem.type && elem.type == 'checkbox'){ 					
				if (!this.behavior.isHandled(elem)) {
					elem.addEventListener('click', function(event){
						self.run(event, elem)
					}, false);
					this.behavior.handleElement(elem);
				}
			}
			break;
			
		default:
			if (!this.behavior.isHandled(elem)) {
				// Other type of element with a switch (links for instance).
				elem.addEventListener('click', function(event){
					self.run(event, elem)
				}, false);
				this.behavior.handleElement(elem);
			}						
			break;
	}
}

/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
wFORMS.behaviors['switch'].instance.prototype.onApply = function() {} 



/**
 * Checks if element is already handled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['switch'].isHandled = function(elem){
	// TODO remove wHandled to final constant
	return elem.getAttribute('rel') && elem.getAttribute('rel').indexOf('wfHandled') > -1;
}

/**
 * Checks if element is already handled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['switch'].handleElement = function(elem){
	// TODO remove wHandled to final constant
	return elem.setAttribute('rel', (elem.getAttribute('rel') || "") + ' wfHandled');
}

/**
 * Removes handle attribute from element
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['switch'].removeHandle = function(elem){
	// TODO remove wHandled to final constant
	if(attr = elem.getAttribute('rel')){
		if(attr == 'wfHandled'){
			elem.removeAttribute('rel');
		}else if(attr.indexOf('wfHandled') != -1){
			elem.setAttribute('rel', attr.replace(/(.*)( wfHandled)(.*)/, "$1$3"));
		}
	}
}

/**
 * Traverse dom tree and look for elements with the switch trigger or target classes. Store in cache object.
 */
wFORMS.behaviors['switch'].instance.prototype.buildCache = function() {
	
	this.cache_processed = new Array();	// stores ids of elements already processed, to prevent duplicate parsing. 
	
	// Run on target first, then all children
	if(this.target.className) {
		if(this.target.className.indexOf(this.behavior.CSS_PREFIX)!=-1) {		
			this.addTriggerToCache(this.target);	
		}
		if(this.target.className.indexOf(this.behavior.CSS_OFFSTATE_PREFIX)!=-1) {
			this.addTargetToCache(this.target);			
		}
		if(this.target.className.indexOf(this.behavior.CSS_ONSTATE_PREFIX)!=-1) {
			this.addTargetToCache(this.target);			
		}
	}
	
	var l = this.target.getElementsByTagName('*');
		
	for(var i=0;i<l.length;i++) {
		if(l[i].tagName) {					
			// Iterates all elements. Lookup for triggers and targets
			if(l[i].className) {
				if(l[i].className.indexOf(this.behavior.CSS_PREFIX)!=-1) {		
					this.addTriggerToCache(l[i]);	
				}
				if(l[i].className.indexOf(this.behavior.CSS_OFFSTATE_PREFIX)!=-1) {
					this.addTargetToCache(l[i]);			
				}
				if(l[i].className.indexOf(this.behavior.CSS_ONSTATE_PREFIX)!=-1) {
					this.addTargetToCache(l[i]);			
				}
			}
		}
	}	
}

/**
 * Merge cache between two behaviors (valid only when applied to the same form).
 */
wFORMS.behaviors['switch'].instance.prototype.merge = function(b) {

	// Merge cache object 
	for(var i in b.cache) {
		if(!this.cache[i]) {
			this.cache[i] = b.cache[i];
			continue;
		}	
		
		for(var j=0; j< b.cache[i].triggers.length; j++) {
			
			for(var k=0; k<this.cache[i].triggers.length && b.cache[i].triggers[j]!=this.cache[i].triggers[k]; k++);
			
			if(k==this.cache[i].triggers.length) {
				this.cache[i].triggers.push(b.cache[i].triggers[j]);
			}
		}
		
		for(var j=0; j< b.cache[i].targets.length; j++) {
			for(var k=0; k<this.cache[i].targets.length && b.cache[i].targets[j]!=this.cache[i].targets[k]; k++);
			
			if(k==this.cache[i].targets.length) {
				this.cache[i].targets.push(b.cache[i].targets[j]);
			}
		}
	}


		
	// Merge cache_processed array.
	for(var i=0;i<b.cache_processed.length;i++) {
		for(var j=0;j<this.cache_processed.length && this.cache_processed[j]!=b.cache_processed[i];j++);
		if(j==this.cache_processed.length) {
			this.cache_processed.push(b.cache_processed[i]);
		}		
	}
}

wFORMS.behaviors['switch'].instance.prototype.isCacheEmpty = function(){
	for(var c in this.cache) {
		return false;
	}
	return true; 
}

/**
 * if argument provided, invalidate cache only if element contains a switch or trigger.
 */
wFORMS.behaviors['switch'].instance.prototype.invalidateCache = function() {
	
	var resetCache = true;
	
	if(arguments.length>0) {			
		var element = document.getElementById(arguments[0]);
		if(element) {
			var resetCache = false;		
			if(!element.querySelectorAll) base2.DOM.bind(element);
			var selector = "*[class*=\""+this.behavior.CSS_PREFIX+"\"], *[class*=\""+this.behavior.CSS_OFFSTATE_PREFIX+"\"], *[class*=\""+this.behavior.CSS_ONSTATE_PREFIX+"\"]";
			var l = element.querySelectorAll(selector);
			if(l.length>0 || element.className && 
							 (element.className.indexOf(this.behavior.CSS_PREFIX)!=-1 || 
							  element.className.indexOf(this.behavior.CSS_OFFSTATE_PREFIX) != -1 ||
							  element.className.indexOf(this.behavior.CSS_ONSTATE_PREFIX)!=-1)) {
				resetCache = true;
			}
		}
	}	
	if(resetCache) {
		this.cache = {};	
		this.buildCache();
	}
}

wFORMS.behaviors['switch'].instance.prototype.addTriggerToCache = function(element) {

	// For selects, make sure to get the <SELECT> element.
	if(element.tagName =='OPTION') {
		var sNode = element.parentNode;
		// Tries to get <select node
		while (sNode && sNode.tagName != 'SELECT'){
			sNode = sNode.parentNode;
		} 
		if(!sNode){
			return; // bad markup
		}
		element = sNode;	
	}
	
	if(!element.id) {
		element.id = wFORMS.helpers.randomId();
	}
	
	for(var j=0;j<this.cache_processed.length;j++) {
		if(this.cache_processed[j]==element.id) {
			return; // already processed (happens for <select>)
		}
	}
	this.cache_processed.push(element.id);

	wFORMS.standardizeElement(element);
						
	var t = this.getTriggers(new Array(element));
	
	for(var i=0;i< t.ON.length; i++) {
		var switchName = t.ON[i];
		
		if(typeof this.cache[switchName]== 'undefined') {
			this.cache[switchName] = { triggers: [], targets: []};
		}
		for(var j=0;j<this.cache[switchName].triggers.length;j++) {
			if(this.cache[switchName].triggers[j]==element) {
				break;
			}
		}
		if(j==this.cache[switchName].triggers.length) {
			this.cache[switchName].triggers.push(element);
		}
	}
	for(var i=0;i< t.OFF.length; i++) {
		var switchName = t.OFF[i];
		if(typeof this.cache[switchName]== 'undefined') {
			this.cache[switchName] = { triggers: [], targets: []};
		}
		for(var j=0;j<this.cache[switchName].triggers.length;j++) {
			if(this.cache[switchName].triggers[j]==element) {
				break;
			}
		}
		if(j==this.cache[switchName].triggers.length) {
			this.cache[switchName].triggers.push(element);
		}
	}		
	
}

wFORMS.behaviors['switch'].instance.prototype.addTargetToCache = function(element) {
		
	wFORMS.standardizeElement(element);
		
	var switchNames = this.behavior.getSwitchNamesFromTarget(element);
			
	for(var i=0;i<switchNames.length; i++) {
		switchName = switchNames[i];
		if(typeof this.cache[switchName]== 'undefined') {
			this.cache[switchName] = { triggers: [], targets: []};
		}
		for(var j=0;j<this.cache[switchName].targets.length;j++) {
			if(this.cache[switchName].targets[j]==element) {
				break;
			}
		}
		if(j==this.cache[switchName].targets.length) {
			this.cache[switchName].targets.push(element);
		}
	}
}

 
/**
 * Returns object with two triggers collection: ON, OFF
 * @param	{Array}	elems	HTML Elements array to create triggers from
 * @param	{Array}	includeSwitches	Only that switches should be included
 * @returns	{Object}	Object of type {ON: Array, OFF: Array}
 *
 */
wFORMS.behaviors['switch'].instance.prototype.getTriggers = function(elems, includeSwitches){
	var o = {
		ON : new Array(), 
		OFF : new Array(), 
		toString : function(){
			return "ON: " + this.ON + "\nOFF: " + this.OFF
		}
	};
	for(var i=0;i<elems.length;i++) {
		var elem = elems[i];
		
		switch(elem.tagName.toUpperCase()){
			case 'OPTION' :
				if(elem.selected){
					o.ON = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
				}else{
					o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
				}
				break;
				
			case 'SELECT' : 
				for(var j=0; j < elem.options.length; j++){
					var opt = elem.options.item(j);
					if(opt.selected){
						o.ON = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(opt, includeSwitches));
					}else{
						o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(opt, includeSwitches));
					}
				}
				break;

			case 'INPUT' : 
					//Test to make sure that elem.form exists (this path called even after section is deleted)
				if(elem.type && elem.type.toUpperCase() == 'RADIO' && elem.form){
					var radioGroup = elem.form[elem.name];
					if(!radioGroup) {
						// repeated radio groups don't show up in the collection in IE6+
						var radioGroup = [];
						var c = elem.form.getElementsByTagName('INPUT');
						for(var k=0;k<c.length;k++) {
							if(c[k].type=='radio' && c[k].name==elem.name) {
								radioGroup.push(c[k]);
							}
						}
					}
					for(var j=radioGroup.length-1;j>=0;j--) {						
						var _elem = radioGroup[j];
						// Do not call getSwitchNamesFromTrigger on this radio input 
						// if we have/will process it anyway because it's part of the 
						// collection being evaluated. 
						if(_elem==elem || !wFORMS.helpers.contains(elems, _elem)) { 							
							if(_elem.checked){
								o.ON  = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(_elem, includeSwitches));
							} else {
								o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(_elem, includeSwitches));
							}						
						}
					}					
				}else if(elem.type && elem.type == 'checkbox'){
					if(elem.checked){
						o.ON = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
					}else{
						o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
					}
				} else {
				    if(elem.hasClass(this.behavior.CSS_ONSTATE_FLAG)){
						o.ON  = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
					}else{
						o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
					}
				}
				break;
				
			default:
				if(elem.hasClass(this.behavior.CSS_ONSTATE_FLAG)){
					o.ON  = o.ON.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
				}else{
					o.OFF = o.OFF.concat(this.behavior.getSwitchNamesFromTrigger(elem, includeSwitches));
				}
				break;
		}
	}
	
	// remove duplicates in arrays
	var _ON = new Array(); 
	for(var i=0;i<o.ON.length;i++) {
		if(!wFORMS.helpers.contains(_ON,o.ON[i])) {
			_ON.push(o.ON[i]);
		}
		
	}
	var _OFF = new Array(); 
	for(var i=0;i<o.OFF.length;i++) {
		if(!wFORMS.helpers.contains(_OFF,o.OFF[i])) {
			_OFF.push(o.OFF[i]);
		}		
	}
	o.ON  = _ON;
	o.OFF = _OFF;
	
	return o;
}

/**
 * Returns all switch names for given trigger element
 * @param	{HTMLElement}	elem
 * @param	{Array}	includeSwitches	Only that switches should be included
 * @return	Array
 */
wFORMS.behaviors['switch'].getSwitchNamesFromTrigger = function(elem, includeSwitches){
	return wFORMS.behaviors['switch'].getSwitchNames(elem.className, "trigger", includeSwitches);
}

/**
 * Returns all switch names for given target element
 * @param	{HTMLElement}	elem
 * @param	{Array}	includeSwitches	Only that switches should be included
 * @return	Array
 */
wFORMS.behaviors['switch'].getSwitchNamesFromTarget = function(elem, includeSwitches){
	return wFORMS.behaviors['switch'].getSwitchNames(elem.className,"target", includeSwitches);
}


/**
 * Returns all switch names for given element
 * @param	{string}	value of class attribute
 * @param	{string}	switch part ('trigger' or 'target') 
 * @param	{Array}		Only these switches should be included
 * @return	Array
 */
wFORMS.behaviors['switch'].getSwitchNames = function(className, switchPart, includeSwitches){
	if(!className || className=='') return [];
	
	var names  = className.split(" ");
	var _names = new Array();
	
	if(switchPart=='trigger') 
		var doTriggers = true;
	else 
		var doTriggers = false; // do switch targets
	
	for(var i=names.length-1;i>=0;i--) {		
		var cn = names[i];
		if(doTriggers) {
			if(cn.indexOf(this.CSS_PREFIX)==0) 
				var sn = cn.substring(this.CSS_PREFIX.length);
		} else {
			if(cn.indexOf(this.CSS_ONSTATE_PREFIX)==0) 
				var sn = cn.substring(this.CSS_ONSTATE_PREFIX.length);
			else if(cn.indexOf(this.CSS_OFFSTATE_PREFIX)==0) 
				var sn = cn.substring(this.CSS_OFFSTATE_PREFIX.length);
		}
		if(sn && (!includeSwitches || wFORMS.helpers.contains(includeSwitches, sn))){
			_names.push(sn);
		}
	}
	return _names;
}

/**
 * 
 */
wFORMS.behaviors['switch'].instance.prototype.getTriggersByTarget = function(target){
	var res = new Array();
	
	var names = wFORMS.behaviors['switch'].getSwitchNamesFromTarget(target);
	var b = wFORMS.behaviors.repeat;

	for(var i=0;i<names.length;i++) {
		var c = this.cache[names[i]];
		if(c) {
			for(j=0; j<c.triggers.length;j++) {
				var elem = c.triggers[j];
				for(var k=0;k<res.length && res[k]!=elem;k++);
				if(k==res.length) {
					res.push(elem);
				} 
			}
		} 
	}
	return this.getTriggers(res, names);	
}

/**
 * Checks if provided element is switched off
 * @param	{HTMLElement}	elem
 * @return	{bool}
 * @public
 */
wFORMS.behaviors['switch'].isSwitchedOff = function(elem){
	return (elem.className.match(
		new RegExp(wFORMS.behaviors['switch'].CSS_OFFSTATE_PREFIX + "[^ ]*")) ?
		true : false) &&
		(elem.className.match(
		new RegExp(wFORMS.behaviors['switch'].CSS_ONSTATE_PREFIX + "[^ ]*")) ?
		false : true) ; 
}

/**
 * Set appropriate classes on switch targets, depending on switch states. 
 * i.e. if control is ON, Targets should be ON. 
 */
wFORMS.behaviors['switch'].instance.prototype.setupTargets = function(){
	var _ran = []; 
	for(var i in this.cache) {	
		for(var j=0; j< this.cache[i].triggers.length; j++) {
			var elem = this.cache[i].triggers[j];
			// an element can have several triggers (ie. select tag), so make sure we run it only once.
			if(!wFORMS.helpers.contains(_ran,elem)) {
				// Switch link state is set with the class 'swtchIsOn'/'swtchIsOff' 
				if(elem.tagName!='A' || elem.hasClass(this.behavior.CSS_ONSTATE_FLAG)) {
					_ran.push(elem);
					this.run(null, elem)
				}			
			}
		}		
	}	
}

wFORMS.behaviors['switch'].instance.prototype.inScope = function(trigger, target) {
	
	var br = wFORMS.behaviors.repeat;
	if(br) {
		var triggerRepeat = trigger;
		while (triggerRepeat && !triggerRepeat.hasClass(br.CSS_REMOVEABLE) &&  !triggerRepeat.hasClass(br.CSS_REPEATABLE)) {						
			triggerRepeat = triggerRepeat.parentNode;
			if(triggerRepeat) {
				wFORMS.standardizeElement(triggerRepeat);
			}			
		}
		
		if (triggerRepeat) {
			// trigger is in a repeated section. Check if target belong to same.
			
			var isInRepeat = false;			
			while(target) {
				if(target.hasClass(br.CSS_REMOVEABLE) ||  target.hasClass(br.CSS_REPEATABLE)) {
					isInRepeat = true;
				}
				if(target==triggerRepeat) {
					return true;
				}
				target = target.parentNode;
				if(target) {
					wFORMS.standardizeElement(target);
				}	
			}
			
			return !isInRepeat;
		}
	}
	return true;
}
/**
 * Executes the behavior
 * @param {event} e Event caught. (!In current implementation it could be null in case of the initialization)
 * @param {domElement} element
 */
wFORMS.behaviors['switch'].instance.prototype.run = function(e, element){ 
	
	wFORMS.standardizeElement(element);
	// If this element does not have a native state attribute (ie. checked/selected)
	// the classes CSS_ONSTATE_FLAG|CSS_OFFSTATE_FLAG are used and must be switched.
	if(element.hasClass(this.behavior.CSS_ONSTATE_FLAG)) {	 	
		element.removeClass(this.behavior.CSS_ONSTATE_FLAG);
		element.addClass(this.behavior.CSS_OFFSTATE_FLAG);
		if(e) e.preventDefault();
		
	} else if(element.hasClass(this.behavior.CSS_OFFSTATE_FLAG)) {
		element.removeClass(this.behavior.CSS_OFFSTATE_FLAG);
		element.addClass(this.behavior.CSS_ONSTATE_FLAG);
		if(e) e.preventDefault();
	}
		
	var triggers = this.getTriggers(new Array(element));
	
	
	for(var i=0; i<triggers.OFF.length;i++) {
		var switchName = triggers.OFF[i];
					
		for(var j=0; j<this.cache[switchName].targets.length;j++) {
			var elem = this.cache[switchName].targets[j];
			
						
			if(!this.inScope(element,elem)) {				
				continue;
			}
						
			wFORMS.standardizeElement(elem);
			elem.addClass(wFORMS.behaviors['switch'].CSS_OFFSTATE_PREFIX + switchName);
			elem.removeClass(wFORMS.behaviors['switch'].CSS_ONSTATE_PREFIX + switchName);			
			var _triggers = this.getTriggersByTarget(elem);
			
			if(_triggers.ON.length == 0){				
				this.behavior.onSwitchOff(elem);
			}
		}				
	}
	for(var i=0; i<triggers.ON.length;i++) {
		var switchName = triggers.ON[i];
		for(var j=0; j<this.cache[switchName].targets.length;j++) {
			var elem = this.cache[switchName].targets[j];
						
			if(!this.inScope(element,elem)) {
				continue;
			}
			
			wFORMS.standardizeElement(elem);
			
			elem.removeClass(this.behavior.CSS_OFFSTATE_PREFIX + switchName);
			elem.addClass(this.behavior.CSS_ONSTATE_PREFIX + switchName);			
			this.behavior.onSwitchOn(elem);			
		}				
	}
		
	if(b = wFORMS.getBehaviorInstance(this.target, 'paging')){
		b.setupManagedControls();
	}	
	this.behavior.onSwitch(this.target);	
}



if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms validation behavior
 * 
 */
wFORMS.behaviors.validation = {
	
	/*
	 * Suffix of the ID for the error message placeholder
 	 */
	ERROR_PLACEHOLDER_SUFFIX : '-E',
	
	
	rules: {	
		oneRequired	: { selector: ".required-one", 		  check: 'validateOneRequired'},
	    isRequired	: { selector: ".required", 			  check: 'validateRequired'}, 
		isAlpha		: { selector: ".validate-alpha", 	  check: 'validateAlpha'},
		isAlphanum	: { selector: ".validate-alphanum",	  check: 'validateAlphanum'}, 
		isDate		: { selector: ".validate-date", 	  check: 'validateDate'}, 
		isTime		: { selector: ".validate-time", 	  check: 'validateTime'}, 
		isEmail		: { selector: ".validate-email", 	  check: 'validateEmail'}, 
		isInteger	: { selector: ".validate-integer", 	  check: 'validateInteger'}, 
		isFloat		: { selector: ".validate-float", 	  check: 'validateFloat'}, 
		isPhone		: { selector: ".validate-phone",	  check: 'validatePhone'},
		isCustom	: { selector: ".validate-custom",	  check: 'validateCustom'}
	},	
	
	styling: {
		fieldError	: "errFld",
		errorMessage: "errMsg"
	},
	
	messages: {
		oneRequired 	: "This section is required.",
		isRequired 		: "This field is required.",
		isAlpha 		: "The text must use alphabetic characters only (a-z, A-Z). Numbers are not allowed.",
		isEmail 		: "This does not appear to be a valid email address.",
		isInteger 		: "Please enter an integer.",
		isFloat 		: "Please enter a number (ex. 1.9).",
		isAlphanum 		: "Please use alpha-numeric characters only [a-z 0-9].",
		isDate 			: "This does not appear to be a valid date.",
		isPhone			: "Please enter a valid phone number.",
		isCustom		: "Please enter a valid value.",
		notification	: "The form is not complete and has not been submitted yet. There was %% problem(s) with your submission."  // %% will be replaced by the actual number of errors.
	},
	
	
	instance: function(f) {
		this.behavior = wFORMS.behaviors.validation; 
		this.target   = f;
		var self 	  = this;
		
		if(!f.__wFormsValidationHandled) {
			if(!f.addEventListener) {
				wFORMS.standardizeElement(f);
			}
			f.addEventListener('submit', function(e){ return self.run(e, this)} ,false);
			f.__wFormsValidationHandled = true;			
		}

        
	},
	
	onPass: function(f,e) {},
	onFail: function(f,e) {},

    dateRegex : (function(){
        var p_month = "((January)|(February)|(March)|(April)|(May)|(June)|(July)|(August)|(September)|(October)|(November)|(December)|(Jan)|(Feb)|(Mar)|(Apr)|(May)|(Jun)|(Jul)|(Aug)|(Sep)|(Oct)|(Nov)|(Dec))";
        var p_num = '\\d{1,2}';
        var year = '(\\d{1,4}|\\d{1,2})';
        var month = '(' + p_num + '|' + p_month + ')';
        var day = '\\d{1,2}((th)|(rd)|(nd)|(st))?';
        var spliter = '\\s*[-/\\\\|\\,\\.]?\\s*';
        var reg_month_day = '((' + month + spliter + day + ')|'
                + '(' + day + spliter + month + ')|(' + month + '))';

        var reg_date = '((' + year + spliter + reg_month_day +')|'
                + '(' + reg_month_day + spliter + year +')|' + reg_month_day + ')';
        var time = '(\\d{1,2}\\s*[:-]?\\s*\\d{1,2}(\\s*[:-]?\\s*\\d{1,2})?)'

        return [
            new RegExp('^' + reg_date + '\\s+' + time + '$', 'i'),
            new RegExp('^' + time + '\\s+' + reg_date + '$', 'i'),
            new RegExp('^' + reg_date + '$', 'i'),
            new RegExp('^' + time  + '$', 'i')
        ];
    })()
}

/**
 * Factory Method
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
wFORMS.behaviors.validation.applyTo = function(f) {
	if(!f || !f.tagName) {
		throw new Error("Can't apply behavior to " + f);
	}
	if(f.tagName!="FORM") {
		// look for form tag in the ancestor nodes.
		if(f.form) 
			f=f.form;
		else {
			var _f = f;
			for(f = f.parentNode; f && f.tagName!="FORM" ;f = f.parentNode) continue;
			if(!f || f.tagName!="FORM") {
				// form tag not found, look for nested forms.
				f = _f.getElementsByTagName('form');				
			}
		}
	}
	if(!f.tagName && f.length>0) {
		var v = new Array();
		for(var i=0;i<f.length;i++) {
			var _v = new wFORMS.behaviors.validation.instance(f[i]);
			v.push(_v);	
			_v.onApply();
		}
	} else {
		var v = new wFORMS.behaviors.validation.instance(f);
		v.onApply();
	}
	
	return v;	   
}
 
/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
wFORMS.behaviors.validation.instance.prototype.onApply = function() {
	var _self = this;

	if(wFORMS.behaviors.repeat && !wFORMS.behaviors.repeat.handlingRepeatedErrors){
		wFORMS.behaviors.repeat.handlingRepeatedErrors = true;
		var _onRepeatCallBack = wFORMS.behaviors.repeat.onRepeat;
		wFORMS.behaviors.repeat.onRepeat = function(elem) {
			if(elem){
				_self.removeErrorMessage(elem);
			}
			var errFld = "*[class*='"+wFORMS.behaviors.validation.styling.fieldError+"']";
			base2.DOM.Element.querySelectorAll(elem,errFld).forEach(function(i){
				_self.removeErrorMessage(i);
			});
			if(_onRepeatCallBack) _onRepeatCallBack.apply(this, arguments);
		}
	}
} 

 
/**
 * Executes the behavior
 * @param {event} 		e 	(optional) 
 * @param {domElement} element
 * @return	{boolean}	true if validation successful, false otherwise (and prevents event propagation)
 */
wFORMS.behaviors.validation.instance.prototype.run = function(e, element) {
	
	// hack to stop to event propagation under paging
	if (e && e.pagingStopPropagation) {
		return false;
	}
	
	var _run = function(element) { 
					
		// Workaround for apparent bug in querySelectorAll not being limited to descendants of 'element':
		// See bug #172 - Check if the element is not on the current page of a multi-page form			
		if(wFORMS.behaviors.paging && !wFORMS.behaviors.paging.isElementVisible(element)) {
			return;	
		}
		
		// Do not validate elements that are switched off by the switch behavior
		if(_self.isSwitchedOff(element))
			return;			
		
		var	value = wFORMS.helpers.getFieldValue(element);	
		if(rule.check.call) {
			var passed = rule.check.call(_self, element, value);
		} else {
			var passed = _self[rule.check].call(_self, element, value);
		}				
			if(!passed) { 
				if(!element.id) element.id = wFORMS.helpers.randomId();
				_self.elementsInError[element.id] = { id:element.id, rule: ruleName };
				_self.removeErrorMessage(element); 
				if(rule.fail) {
					// custom fail method
					rule.fail.call(_self, element, ruleName);
				} else {
					// default fail method
					_self.fail.call(_self, element, ruleName);
				} 					
				errorCount ++;
			} else {
				// If no previos rule has found an error on that field,
				// remove any error message from a previous validation run.
				if(!_self.elementsInError[element.id])
					_self.removeErrorMessage(element);
				
				if(rule.pass) {
 				// runs custom pass method. 
 				rule.pass.call(_self, element);
 			} else {
 				// default pass method
 				_self.pass.call(_self, element);
 			}	 			
		}
	}
	

 	var errorCount = 0;
 	this.elementsInError = {};
 	for (var ruleName in this.behavior.rules) {
 		var rule = this.behavior.rules[ruleName];
   		var _self = this;

		//Seems to be an IE9 issue with DOM.bind, switched to standardizeElement instead
		if(!element.matchesSelector)
			wFORMS.standardizeElement(element);
		if(!element.matchesSelector)
			element = base2.DOM.bind(element);	

		//Maybe move this to crossbrowser hacks?
		//IE9 doesn't implement Element.matchesSelector ... oh wait
		//yes it does, it just calls it msMatchesSelector
		if(!element.matchesSelector && element.msMatchesSelector)
			element.matchesSelector = element.msMatchesSelector;
		if(!element.matchesSelector && element.mozMatchesSelector)
			element.matchesSelector = element.mozMatchesSelector;
		if(!element.matchesSelector && element.webkitMatchesSelector)
			element.matchesSelector = element.webkitMatchesSelector;
		if(!element.matchesSelector)
			element.matchesSelector = base2.DOM.Element.matchesSelector;
			
		/* run validation if rule matches current element */
		if(element.matchesSelector(rule.selector)) { 
			_run(element);			
		}
		
		/* check descendant nodes and run validation on matching elements */
 		element.querySelectorAll(rule.selector).forEach(_run);
 	}
	
 	if(errorCount > 0) {
 		if(e) {
 			e.preventDefault?e.preventDefault():e.returnValue = false;
 		}
 		if(this.behavior.onFail) this.behavior.onFail(this, e);
 		return false;
 	}
 	if(this.behavior.onPass) this.behavior.onPass(this, e);
 	return true; 
}




/**
 * fail
 * @param {domElement} element 
 */
/**
 * fail
 * @param {domElement} element 
 */
wFORMS.behaviors.validation.instance.prototype.fail = function(element, ruleName) { 

	
	//  field wrapper DIV. (-D suffix)
	var div = document.getElementById(element.id+'-D');
	
	if(!div && wFORMS.behaviors.repeat) {
		if(element.id){
			var name = element.id.replace(/(\[\d+\])+(\-[HED])?$/,"$2");
			var suffix = element.id.split(name).join('');
			name += '-D';
			if(suffix){
				name += suffix;
			}
			div  = document.getElementById(name);
		}
	}
	
	// set class to show that the field has an error
	if(div) {	
		if(!div.hasClass) wFORMS.standardizeElement(div);
		div.addClass(this.behavior.styling.fieldError);
	}else{
		// set class to show that the field has an error
		if(!element.hasClass) wFORMS.standardizeElement(element);
		element.addClass(this.behavior.styling.fieldError);	
	}
	
	// show error message.
	this.addErrorMessage(element, this.behavior.messages[ruleName]);			
},
	
/**
 * pass
 * @param {domElement} element 
 */	
wFORMS.behaviors.validation.instance.prototype.pass = function(element) { /* no implementation needed */ }

/**
 * addErrorMessage
 * @param {domElement} element 
 * @param {string} error message 
 */
wFORMS.behaviors.validation.instance.prototype.addErrorMessage = function(element, message) {
	
	// we'll need an id here.
	if (!element.id) element.id = wFORMS.helpers.randomId(); 
	
	// Prepare error message
	var txtNode = document.createElement('span');
	txtNode.appendChild(document.createTextNode(message));
	
	// Find error message placeholder.
	var p = document.getElementById(element.id + this.behavior.ERROR_PLACEHOLDER_SUFFIX);
	if(!p) { // create placeholder.
		p = document.createElement("div"); 
		p.setAttribute('id', element.id + this.behavior.ERROR_PLACEHOLDER_SUFFIX);
		if(element.tagName=="TR") {
			// If this is a table row, add error message to first cell.		
			if(element.getElementsByTagName('TH').length>0) {
				p = (element.getElementsByTagName('TH')[0]).appendChild(p);
			} else {
				p = (element.getElementsByTagName('TD')[0]).appendChild(p);
			}
		} else {
			if(element.hasClass("wfSection") || element.hasClass("inlineSection")) {
				p = element.appendChild(p);				
			} else {	
				// If we find a field wrapper, append error message to it.
				var div = document.getElementById(element.id+'-D');
				if(div) {
					p = div.appendChild(p);
				} else {
					// last resort, place the error message just after the field.
					p = element.parentNode.insertBefore(p,element.nextSibling);
				}
			}
		}
	}
	// Finish the error message.
	p.appendChild(txtNode);
	wFORMS.standardizeElement(p);  
	p.addClass(this.behavior.styling.errorMessage);							
}

/**
 * removeErrorMessage
 * @param {domElement} element 
 */
wFORMS.behaviors.validation.instance.prototype.removeErrorMessage = function(element) { 
	
	//  field wrapper DIV. (-D suffix)
	var div = document.getElementById(element.id+'-D');
	
	if(!element.hasClass) wFORMS.standardizeElement(element);
	if(!element.removeClass) wFORMS.standardizeElement(element);
	if(div && !div.hasClass) wFORMS.standardizeElement(div);
	if(div && !div.removeClass) wFORMS.standardizeElement(div);
	
	if(element.hasClass(this.behavior.styling.fieldError)) {
		element.removeClass(this.behavior.styling.fieldError);
	}
	if(div && div.hasClass(this.behavior.styling.fieldError)) {
		div.removeClass(this.behavior.styling.fieldError);
	}
	
	var errorMessage  = document.getElementById(element.id + this.behavior.ERROR_PLACEHOLDER_SUFFIX);
	if(errorMessage)  {
		errorMessage.parentNode.removeChild(errorMessage); 
	}else{
		//Handle nested repeated sections
		if(element.id){
			var name = element.id.split('-D').join('');
			var errorMessage  = document.getElementById(name + this.behavior.ERROR_PLACEHOLDER_SUFFIX);
			if(errorMessage)  {
				errorMessage.parentNode.removeChild(errorMessage); 
			}
		}
	}
	
}

/**
 * Checks the element's 'visibility' (switch behavior)
 * @param {domElement} element 
 * @return	{boolean}	true if the element is not 'visible' (switched off), false otherwise.
 */
wFORMS.behaviors.validation.instance.prototype.isSwitchedOff = function(element) {
	var sb = wFORMS.getBehaviorInstance(this.target,'switch');
	if(sb) { 
		var parentElement = element;
		while(parentElement && parentElement.tagName!='BODY') {
			// TODO: Check what happens with elements with multiple ON and OFF switches	
			if(parentElement.className && 
			   parentElement.className.indexOf(sb.behavior.CSS_OFFSTATE_PREFIX)!=-1 &&
			   parentElement.className.indexOf(sb.behavior.CSS_ONSTATE_PREFIX)==-1
			   ) {
				// switched off. skip element.
				return true;
			}
			parentElement = parentElement.parentNode;
		}
	}	
	return false;
}
 
/**
 * Checks if the element with the given id is a placeholder for the error message
 * @param {domElement} element 
 * @return	{boolean}	true if the element is a placeholder, false otherwise.
 */
wFORMS.behaviors.validation.isErrorPlaceholderId = function(id) {
	return id.match(new RegExp(wFORMS.behaviors.validation.ERROR_PLACEHOLDER_SUFFIX + '$')) != null;
} 
  
/**
 * Checks if the given string is empty (null or whitespace only)
 * @param {string} s 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.isEmpty = function(s) {				
	var regexpWhitespace = /^\s+$/;
	return  ((s == null) || (s.length == 0) || regexpWhitespace.test(s));
}

/**
 * validateRequired
 * @param {domElement} element 
 * @param {string} element's value (if available) 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateRequired = function(element, value) {
		
	switch(element.tagName) {
		case "INPUT":
			var inputType = element.getAttribute("type");					
			if(!inputType) inputType = 'text'; 
			switch(inputType.toLowerCase()) {
				case "checkbox":
				case "radio":
					return element.checked; 
					break;
				case "file":
					// allows form to pass validation if a file has already been uploaded 
					// (tfa_uploadDelete_xx checkbox exists and is not checked)					
					var deleteCheckbox=document.getElementById('tfa_uploadDelete_'+element.id);
					if(this.isEmpty(value)) {
						return (deleteCheckbox && !deleteCheckbox.checked);						
					}
					return true;
					break;
				default:
					return !this.isEmpty(value);
			}
			break;
		case "SELECT":							
			return !this.isEmpty(value);
			break;
		case "TEXTAREA":
			return !this.isEmpty(value);
			break;
		default:
			return this.validateOneRequired(element);
			break;
	} 	 
	return false 
};

/**
 * validateOneRequired
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateOneRequired = function(element) {
	if(element.nodeType != 1) return false;
	
	if(this.isSwitchedOff(element))
		return false;	
	
	switch(element.tagName) {
		case "INPUT":
			var inputType = element.getAttribute("type");
			if(!inputType) inputType = 'text'; 
			switch(inputType.toLowerCase()) {
				case "checkbox":
				case "radio":
					return element.checked; 
					break;
				case "file":
					// allows form to pass validation if a file has already been uploaded 
					// (tfa_uploadDelete_xx checkbox exists and is not checked)
					var deleteCheckbox=document.getElementById('tfa_uploadDelete_'+element.id);
					if(this.isEmpty(wFORMS.helpers.getFieldValue(element))) {
						return (deleteCheckbox && !deleteCheckbox.checked);						
					}
					return true;
					break;
				default:
					return !this.isEmpty(wFORMS.helpers.getFieldValue(element));
			}
			break;
		case "SELECT":							
			return !this.isEmpty(wFORMS.helpers.getFieldValue(element));
			break;
		case "TEXTAREA":
			return !this.isEmpty(wFORMS.helpers.getFieldValue(element));
			break;
		default:
			for(var i=0; i<element.childNodes.length;i++) {
				if(this.validateOneRequired(element.childNodes[i])) return true;
			}
			break;
	} 	 
	return false 
}

/**
 * validateAlpha
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateAlpha = function(element, value) {
	var regexp = /^[a-zA-Z\s]+$/; // Add ' and - ?
	return this.isEmpty(value) || regexp.test(value);
}

/**
 * validateAlphanum
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateAlphanum = function(element, value) {
	var regexp = /^[\w\s]+$/;
	return this.isEmpty(value) || regexp.test(value);
}

/**
 * validateDate
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateDate = function(element, value) {
    if(this.isEmpty(value)){
        return true;
    }

    var regex = wFORMS.behaviors.validation.dateRegex;
    for(var i = 0; i < regex.length - 1; i++){
        if (regex[i].test(value)) {
			return true;
		}
    }

	return false;
}

/**
 * validateTime
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateTime = function(element, value) {
	/* not yet implemented */	
	return true;
}

/**
 * validateEmail
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateEmail = function(element, value) {
	var regexpEmail = /\w{1,}[@][\w\-]{1,}([.]([\w\-]{1,})){1,}$/;
	return this.isEmpty(value) || regexpEmail.test(value);
}

/**
 * validateInteger
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateInteger = function(element, value) {
	var regexp = /^[\-+]?\d+$/;
	return this.isEmpty(value) || regexp.test(value);
}

/**
 * validateFloat
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateFloat = function(element, value) {
	var regexp = /^((([1-9]\d*|0)?\.\d+)|([1-9]\d*))$/;
	return this.isEmpty(value) || regexp.test(value);
}

/**
 * validatePhone
 * @param {domElement} element
 * @returns {boolean}
 */
wFORMS.behaviors.validation.instance.prototype.validatePhone = function(element, value) {
	if (this.isEmpty(value)) {
		return true;
	}
	var formats = [
		/^[\d\-\. \+\(\)]+$/, // any combination of valid characters
		/^[\d\-\. \+\(\)]+ # {0,1}\d+ *$/, // with hash extension
		/^[\d\-\. \+\(\)]+ ext\.{0,1} \d+ *$/ // with abbreviated extension
	];
	for (var f in formats) {
		if (formats[f].test(value)) {
			return true;
		}
	}
	return false;
}

/**
 * validateCustom
 * @param {domElement} element 
 * @returns {boolean} 
 */
wFORMS.behaviors.validation.instance.prototype.validateCustom = function(element, value) {	
	var pattern = new RegExp("\/(.*)\/([gi]*)");
	var matches = element.className.match(pattern);
	if (this.isEmpty(value)) {
		return true;
	}	
	if(matches && matches[0]) {										
		var validationPattern = new RegExp(matches[1],matches[2]);
		if(!value.match(validationPattern)) {
			return false									
		}
	}		
	return true;
}

if (typeof(wFORMS) == "undefined") {
	throw new Error("wFORMS core not found. This behavior depends on the wFORMS core.");
}
/**
 * wForms calculation behavior. 
 */
wFORMS.behaviors.calculation  = { 
	
	/**
	 * Selector expression for the variable used in a calculation
     * @final
     * @see	http://www.w3.org/TR/css3-selectors/
	 */
	VARIABLE_SELECTOR_PREFIX : "calc-",
	
	/**
	 * Behavior uses value defined in the class with this prefix if available (e.g. calcval-9.99)
	 * otherwise uses field value property. 
	 */
	CHOICE_VALUE_SELECTOR_PREFIX : "calcval-",

	/**
	 * Suffix of the ID for the hint element
     * @final
	 */
	CALCULATION_SELECTOR : '*[class*="formula="]',

	/**
	 * The error message displayed next to a field with a calculation error
	 */
	CALCULATION_ERROR_MESSAGE : "There was an error computing this field.",
	
	/**
	 * Creates new instance of the behavior
     * @constructor
	 */
	instance : function(f) {
		this.behavior = wFORMS.behaviors.calculation; 
		this.target = f;
		this.calculations = [];
		//this.variables = [];
	}
}

/**
 * Factory Method.
 * Applies the behavior to the given HTML element by setting the appropriate event handlers.
 * @param {domElement} f An HTML element, either nested inside a FORM element or (preferably) the FORM element itself.
 * @return {object} an instance of the behavior 
 */	
wFORMS.behaviors.calculation.applyTo = function(f) {
	
	
	while(f && f.tagName!='FORM') {
		f = f.parentNode;
	}
	
	var b = wFORMS.getBehaviorInstance(f,'calculation');
	if(!b) { 
		b = new wFORMS.behaviors.calculation.instance(f);
	} else {
		b.calculations = [];
	}
	
	if(wFORMS.behaviors.repeat && !b._repeatRemoveHandler) {
		var _callback = wFORMS.behaviors.repeat.onRemove;
		b._repeatRemoveHandler = function() {
			wFORMS.behaviors.calculation.applyTo(f);
			if(_callback) _callback.apply(this, arguments);
		}
		wFORMS.behaviors.repeat.onRemove = b._repeatRemoveHandler; 
	}
	
	
	f.querySelectorAll(wFORMS.behaviors.calculation.CALCULATION_SELECTOR).forEach(
		function(elem){
			// extract formula
			var formula = elem.className.substr(elem.className.indexOf('formula=')+8).split(' ')[0];

			var variables = formula.split(/[^a-zA-Z]+/g);
			b.varFields = [];
			
			// process variables, add onchange/onblur event to update total.
			for (var i = 0; i < variables.length; i++) {
				if(variables[i]!='') {
					
					/* 
					Binding with forEach sometime fails when using this, resulting in undefined 'variable' parameter. 
						f.querySelectorAll("*[class*=\"...\"]");
					Library call works fine: base2.DOM.Document.querySelectorAll(...) 
					*/
					base2.DOM.Document.querySelectorAll(f,"*[class*=\""+wFORMS.behaviors.calculation.VARIABLE_SELECTOR_PREFIX+variables[i]+"\"]").forEach(
						function(variable){
							if(!variable.addEventListener) {
								base2.DOM.bind(variable);
							}
							// make sure the variable is an exact match.
							var exactMatch = ((' ' + variable.className + ' ').indexOf(' '+wFORMS.behaviors.calculation.VARIABLE_SELECTOR_PREFIX+variables[i]+' ')!=-1);
							if(!exactMatch) return;
							
							// listen for value changes
							if(!wFORMS.behaviors.calculation.isHandled(variable)){
								var t = variable.tagName.toLowerCase();
								if (t == 'input' || t == 'textarea') {
									
									// toggled fields
									var y = variable.type.toLowerCase();
									if (t == 'input' && (y == 'radio' || y == 'checkbox')) {
										variable.addEventListener('click', function(e){ return b.run(e, this)}, false);
										wFORMS.behaviors.calculation.setHandledFlag(variable);
									
									// text entry fields
									} else {
										variable.addEventListener('blur', function(e){ return b.run(e, this)}, false);
										wFORMS.behaviors.calculation.setHandledFlag(variable);
									}
									
								// select boxes
								} else if (t == 'select') {
									variable.addEventListener('change',  function(e){ return b.run(e, this)}, false);
									wFORMS.behaviors.calculation.setHandledFlag(variable);
									
								// unsupported elements	
								} else {
									return;
								}
							}
							
							b.varFields.push({name: variables[i], field: variable});						
						}
					);			
				}		
			}		
			var calc = { field: elem, formula: formula, variables: b.varFields };		
			b.calculations.push(calc);	
			b.compute(calc);
		}
	);
	
	b.onApply();
	
	return b;
}

/**
 * Executed once the behavior has been applied to the document.
 * Can be overwritten.
 */
wFORMS.behaviors.calculation.instance.prototype.onApply = function() {} 

/**
 * Runs when a field is changed, update dependent calculated fields. 
 * @param {event} event
 * @param {domElement} elem
 */
wFORMS.behaviors.calculation.instance.prototype.run = function(event, element) {

	for(var i=0; i<this.calculations.length;i++) {		
		var calc = this.calculations[i];
		for(var j=0; j<calc.variables.length;j++) {		
					
			if(element==calc.variables[j].field) {
				// this element is part of the calculation for calc.field
				this.compute(calc);
			}
		}
	}
} 

/**
 * Can be used to update a calculated field if the run method is not triggered. 
 * @param {event} event
 * @param {domElement} elem
 */
wFORMS.behaviors.calculation.instance.prototype.refresh = function(event, element) { 
	
	for(var i=0; i<this.calculations.length;i++) {		
		var calc = this.calculations[i];
					
		if(element==calc.field) {
			this.compute(calc);
		}
	}
} 
 
wFORMS.behaviors.calculation.instance.prototype.compute = function(calculation) {
	var f = this.target;
	var formula = calculation.formula;
	var _processedVariables = new Array();
	
	for(var i=0; i<calculation.variables.length;i++) {
		var v = calculation.variables[i];
		var varval = 0;
		var _self  = this;
		
		// We don't rely on calculation.variables[i].field because 
		// the form may have changed since we've applied the behavior
		// (repeat behavior for instance).
		
		// Since the calculations can have several variables with the same name
		// querySelectorAll will catch them all, so we don't need to also loop 
		// through all of them.
		if(wFORMS.helpers.contains(_processedVariables,v.name)) {
			continue;
		} else {
			_processedVariables.push(v.name);
		}
		 
		// TODO: Exclude switched-off variables?
		
		/* 
		Binding with forEach sometime fails when using this, resulting in undefined 'variable' parameter. 
			f.querySelectorAll("*[class*=\"...\"]");
		Library call works fine: base2.DOM.Document.querySelectorAll(...) 
		*/
		base2.DOM.Document.querySelectorAll(f,"*[class*=\""+_self.behavior.VARIABLE_SELECTOR_PREFIX+v.name+"\"]").forEach(
			function(variable){
								
				// make sure the variable is an exact match.
				var exactMatch = ((' ' + variable.className + ' ').indexOf(' '+wFORMS.behaviors.calculation.VARIABLE_SELECTOR_PREFIX+v.name+' ')!=-1);
				if(!exactMatch) return;
				
				
				if(!_self.inScope(calculation.field, variable)){
					return;
				}
				
				
				// If field value has a different purpose, the value for the calculation can be set in the
				// class attribute, prefixed with CHOICE_VALUE_SELECTOR_PREFIX
				if(_self.hasValueInClassName(variable)) {
					var value = _self.getValueFromClassName(variable);
				} else {
					var value = wFORMS.helpers.getFieldValue(variable);					
				} 
				if(!value) value=0;
				
				if(value.constructor==Array) { // array (multiple select)
					for(var j=0;j<value.length;j++) { 
						if(String(value[j]).search(/^[\d\.,]*$/) != -1)
							varval += parseFloat(value[j]);
						else
							(!varval)?(varval=value[j]):(varval=String(varval).concat(value[j]));
					}
				} else {
						if(String(value).search(/^[\d\.,]*$/) != -1) 
							varval += parseFloat(value);
						else
							(!varval)?(varval=value):(varval=String(varval).concat(value));
				}
			}
		);		
		
		// prepend variable assignment to the formula
		if(String(varval).search(/^[\d\.,]*$/) != -1) {
			formula = 'var '+ v.name +' = '+ varval +'; '+ formula;
		} else {
			formula = 'var '+ v.name +' = "'+ varval.replace(/\"/g, '\\"') +'"; '+ formula;
		}
	} 
	  
	try {
		var calc = function () {return eval(formula)};
		var result = calc();
		if(result == 'Infinity' || result == 'NaN' || String(result).match('NaN')){
			result = 'error';
		}
	} catch(x) {		
		result = 'error';	
	} 
	// Check if validation behavior is available. Then flag field if error.
	var validationBehavior = wFORMS.getBehaviorInstance(this.target,'validation');	
	if(validationBehavior) {		
		// add validation error message 
		if(!wFORMS.behaviors.validation.messages['calculation']) {
			wFORMS.behaviors.validation.messages['calculation'] = this.behavior.CALCULATION_ERROR_MESSAGE;
		}
		validationBehavior.removeErrorMessage(calculation.field);
		if(result=='error') {			
			validationBehavior.fail(calculation.field, 'calculation');
		}
	}
	calculation.field.value = result;
	
	// If the calculated field is also a variable, recursively update dependant calculations
	if(calculation.field.className && (calculation.field.className.indexOf(this.behavior.VARIABLE_SELECTOR_PREFIX)!=-1)) {
		// TODO: Check for infinite loops?
		//console.log('rec',this);
		this.run(null,calculation.field);
	} 
}
	
wFORMS.behaviors.calculation.instance.prototype.hasValueInClassName = function(element) {
	switch(element.tagName) {
		case "SELECT": 
			for(var i=0;i<element.options.length;i++) {
				if(element.options[i].className && element.options[i].className.indexOf(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)!=-1) {
					return true; 
				}
			}
			return false; 
			break;
		default:
			if(!element.className || (' '+element.className).indexOf(' '+this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)==-1)
				return false;
			break;
	}
	return true;
}
/**
 * getValueFromClassName 
 * If field value has a different purpose, the value for the calculation can be set in the
 * class attribute, prefixed with CHOICE_VALUE_SELECTOR_PREFIX 
 * @param {domElement} element 
 * @returns {string} the value of the field, as set in the className
 */
wFORMS.behaviors.calculation.instance.prototype.getValueFromClassName = function(element) {
	switch(element.tagName) {
		case "INPUT":
			if(!element.className || element.className.indexOf(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)==-1) 
				return null;
			
			var value = element.className.split(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)[1].split(' ')[0];								
			if(element.type=='checkbox')
				return element.checked?value:null;
			if(element.type=='radio')
				return element.checked?value:null;
			return value;
			break;
		case "SELECT":		
			if(element.selectedIndex==-1) {					
				return null; 
			} 
			if (element.multiple) {
				var v=[];
				for(var i=0;i<element.options.length;i++) {
					if(element.options[i].selected) {
						if(element.options[i].className && element.options[i].className.indexOf(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)!=-1) { 
							var value = element.options[i].className.split(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)[1].split(' ')[0];								
							v.push(value);
						}
					}
				}
				if(v.length==0) return null;
				return v;
			}	
			if (element.options[element.selectedIndex].className &&  element.options[element.selectedIndex].className.indexOf(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)!=-1) { 
				var value =  element.options[element.selectedIndex].className.split(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)[1].split(' ')[0];								
				return value;
			}													
			break;
		case "TEXTAREA":
			if(!element.className || element.className.indexOf(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)==-1) 
				return null;
			var value = element.className.split(this.behavior.CHOICE_VALUE_SELECTOR_PREFIX)[1].split(' ')[0];								
			
			return value;
			break;
		default:
			return null; 
			break;
	} 	 
	return null; 
}


/**
 * Checks if element is already handled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['calculation'].isHandled = function(elem){
	return (elem._wforms_calc_handled === true);
}

/**
 * set element as already handled
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['calculation'].setHandledFlag = function(elem){
	elem._wforms_calc_handled = true;
}

/**
 * Removes handle attribute from element
 * @param	{HTMLElement}	elem
 * @return	boolean
 */
wFORMS.behaviors['calculation'].removeHandledFlag = function(elem){
	try {
		delete elem._wforms_calc_handled;
	} catch(e) {
		elem._wforms_calc_handled = undefined; // Workaround  for <IE8
	}
}

 
 wFORMS.behaviors.calculation.instance.prototype.inScope = function(formula, variable) {
		
		var br = wFORMS.behaviors.repeat;
		if(br) {
			var formulaRepeat = formula;
			if(!formulaRepeat.hasClass) {
				wFORMS.standardizeElement(formulaRepeat);
			}
			while (formulaRepeat && !formulaRepeat.hasClass(br.CSS_REMOVEABLE) &&  !formulaRepeat.hasClass(br.CSS_REPEATABLE)) {						
				formulaRepeat = formulaRepeat.parentNode;
				if(formulaRepeat) {
					wFORMS.standardizeElement(formulaRepeat);
				}			
			}
			
			if (formulaRepeat) {
				// formula is in a repeated section. Check if variable belong to same.
				
				var isInRepeat = false;			
				while(variable) {
					if(!variable.hasClass) {
						wFORMS.standardizeElement(variable);
					}
					if(variable.hasClass(br.CSS_REMOVEABLE) ||  variable.hasClass(br.CSS_REPEATABLE)) {
						isInRepeat = true;
					}
					if(variable==formulaRepeat) {
						return true;
					}
					variable = variable.parentNode;
					if(variable) {
						wFORMS.standardizeElement(variable);
					}	
				}
				
				return !isInRepeat;
			}
		}
		return true;
	}
